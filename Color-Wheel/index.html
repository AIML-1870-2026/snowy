<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Wheel - Stage Lighting</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            background: #0a0a0f;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        /* Stage Area */
        #stage-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        #stage {
            width: 100%;
            height: 100%;
        }

        /* Control Panel */
        #control-panel {
            background: linear-gradient(to bottom, #1a1a2e, #0f0f1a);
            border-top: 3px solid #333;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 40px;
            box-shadow: 0 -10px 30px rgba(0,0,0,0.5);
        }

        /* Control Panel Frame */
        .panel-section {
            background: #12121f;
            border: 2px solid #2a2a4a;
            border-radius: 10px;
            padding: 15px;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);
        }
        .panel-label {
            color: #6a6a8a;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
            text-align: center;
        }

        /* Color Wheel */
        #wheel-container {
            position: relative;
            width: 150px;
            height: 150px;
        }
        #color-wheel {
            cursor: crosshair;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(255,255,255,0.1);
        }
        #wheel-selector {
            position: absolute;
            width: 12px;
            height: 12px;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        /* Harmony Buttons */
        .harmony-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .harmony-btn {
            background: #1a1a2e;
            border: 1px solid #3a3a5a;
            color: #8a8aaa;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }
        .harmony-btn:hover {
            background: #2a2a4e;
            border-color: #5a5a7a;
        }
        .harmony-btn.active {
            background: #3a3a6e;
            border-color: #7a7aaa;
            color: #fff;
            box-shadow: 0 0 10px rgba(100, 100, 200, 0.3);
        }

        /* Color Preview */
        .color-preview {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .preview-swatch {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            border: 2px solid #3a3a5a;
        }
        #main-swatch { box-shadow: 0 0 15px currentColor; }

        /* LED Indicator */
        .led-strip {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-top: 10px;
        }
        .led {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #333;
        }
        .led.on {
            background: #0f0;
            box-shadow: 0 0 5px #0f0;
        }
    </style>
</head>
<body>
    <div id="stage-container">
        <canvas id="stage"></canvas>
    </div>

    <div id="control-panel">
        <div class="panel-section">
            <div class="panel-label">Main Spotlight</div>
            <div id="wheel-container">
                <canvas id="color-wheel" width="150" height="150"></canvas>
                <div id="wheel-selector"></div>
            </div>
            <div class="led-strip">
                <div class="led on"></div>
                <div class="led on"></div>
                <div class="led on"></div>
            </div>
        </div>

        <div class="panel-section">
            <div class="panel-label">Harmony Mode</div>
            <div class="harmony-buttons">
                <button class="harmony-btn active" data-harmony="complementary">Complementary</button>
                <button class="harmony-btn" data-harmony="analogous">Analogous</button>
                <button class="harmony-btn" data-harmony="triadic">Triadic</button>
                <button class="harmony-btn" data-harmony="split">Split-Complementary</button>
            </div>
        </div>

        <div class="panel-section">
            <div class="panel-label">Active Colors</div>
            <div class="color-preview">
                <div class="preview-swatch" id="left-swatch"></div>
                <div class="preview-swatch" id="main-swatch"></div>
                <div class="preview-swatch" id="right-swatch"></div>
            </div>
            <div class="led-strip">
                <div class="led on"></div>
                <div class="led"></div>
                <div class="led on"></div>
            </div>
        </div>
    </div>

    <script>
        // ===== CONFIGURATION =====
        let selectedHue = 0;
        let selectedSat = 100;
        let harmonyType = 'complementary';

        // ===== CANVAS SETUP =====
        const stage = document.getElementById('stage');
        const stageCtx = stage.getContext('2d');
        const wheel = document.getElementById('color-wheel');
        const wheelCtx = wheel.getContext('2d');
        const selector = document.getElementById('wheel-selector');

        function resizeStage() {
            const container = document.getElementById('stage-container');
            stage.width = container.clientWidth;
            stage.height = container.clientHeight;
            drawScene();
        }

        // ===== COLOR UTILITIES =====
        function hslToRgb(h, s, l) {
            s /= 100;
            l /= 100;
            const k = n => (n + h / 30) % 12;
            const a = s * Math.min(l, 1 - l);
            const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
            return [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
        }

        function rgbToString(rgb) {
            return `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
        }

        function getHarmonyColors(hue, type) {
            const colors = { left: [], right: [] };

            switch(type) {
                case 'complementary':
                    colors.left = [hslToRgb((hue + 180) % 360, 100, 50)];
                    colors.right = [hslToRgb((hue + 180) % 360, 100, 50)];
                    break;
                case 'analogous':
                    colors.left = [hslToRgb((hue + 330) % 360, 100, 50)];
                    colors.right = [hslToRgb((hue + 30) % 360, 100, 50)];
                    break;
                case 'triadic':
                    colors.left = [hslToRgb((hue + 120) % 360, 100, 50)];
                    colors.right = [hslToRgb((hue + 240) % 360, 100, 50)];
                    break;
                case 'split':
                    colors.left = [hslToRgb((hue + 150) % 360, 100, 50)];
                    colors.right = [hslToRgb((hue + 210) % 360, 100, 50)];
                    break;
            }
            return colors;
        }

        // ===== COLOR WHEEL =====
        function drawColorWheel() {
            const cx = 75, cy = 75, radius = 70;

            // Draw hue wheel
            for (let angle = 0; angle < 360; angle++) {
                const startAngle = (angle - 1) * Math.PI / 180;
                const endAngle = (angle + 1) * Math.PI / 180;

                wheelCtx.beginPath();
                wheelCtx.moveTo(cx, cy);
                wheelCtx.arc(cx, cy, radius, startAngle, endAngle);
                wheelCtx.closePath();

                const rgb = hslToRgb(angle, 100, 50);
                wheelCtx.fillStyle = rgbToString(rgb);
                wheelCtx.fill();
            }

            // Center gradient for saturation/lightness
            const gradient = wheelCtx.createRadialGradient(cx, cy, 0, cx, cy, radius);
            gradient.addColorStop(0, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            wheelCtx.fillStyle = gradient;
            wheelCtx.beginPath();
            wheelCtx.arc(cx, cy, radius, 0, Math.PI * 2);
            wheelCtx.fill();
        }

        function updateSelector() {
            const cx = 75, cy = 75;
            const dist = (100 - selectedSat) * 0.5;
            const angle = selectedHue * Math.PI / 180;
            const x = cx + Math.cos(angle) * (60 - dist * 0.5);
            const y = cy + Math.sin(angle) * (60 - dist * 0.5);
            selector.style.left = x + 'px';
            selector.style.top = y + 'px';

            const rgb = hslToRgb(selectedHue, 100, 50);
            selector.style.backgroundColor = rgbToString(rgb);
        }

        // ===== STAGE ELEMENTS =====
        function drawCeiling(ctx, w, h, ceilingY) {
            // Ceiling base
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, w, ceilingY);

            // Ceiling panels/beams
            ctx.fillStyle = '#252525';
            const beamWidth = w / 8;
            for (let i = 0; i < 8; i++) {
                ctx.fillRect(i * beamWidth, 0, beamWidth - 2, ceilingY);
            }

            // Lighting rig bar
            ctx.fillStyle = '#333';
            ctx.fillRect(0, ceilingY - 8, w, 8);
            ctx.fillStyle = '#444';
            ctx.fillRect(0, ceilingY - 6, w, 2);
        }

        function drawCurtains(ctx, w, h, ceilingY, floorY) {
            const curtainWidth = w * 0.12;
            const folds = 8;
            const foldWidth = curtainWidth / folds;

            // Left curtain
            for (let i = 0; i < folds; i++) {
                const x = i * foldWidth;
                const shade = i % 2 === 0 ? '#4a1a1a' : '#3a0a0a';
                ctx.fillStyle = shade;
                ctx.beginPath();
                ctx.moveTo(x, ceilingY);
                ctx.lineTo(x + foldWidth, ceilingY);
                ctx.lineTo(x + foldWidth, floorY);
                ctx.lineTo(x, floorY);
                ctx.closePath();
                ctx.fill();
            }

            // Right curtain
            for (let i = 0; i < folds; i++) {
                const x = w - curtainWidth + i * foldWidth;
                const shade = i % 2 === 0 ? '#4a1a1a' : '#3a0a0a';
                ctx.fillStyle = shade;
                ctx.beginPath();
                ctx.moveTo(x, ceilingY);
                ctx.lineTo(x + foldWidth, ceilingY);
                ctx.lineTo(x + foldWidth, floorY);
                ctx.lineTo(x, floorY);
                ctx.closePath();
                ctx.fill();
            }

            // Curtain valance (top drape)
            ctx.fillStyle = '#5a2020';
            ctx.beginPath();
            ctx.moveTo(0, ceilingY);
            ctx.lineTo(w, ceilingY);
            ctx.lineTo(w, ceilingY + 25);
            for (let x = w; x >= 0; x -= 40) {
                ctx.quadraticCurveTo(x - 20, ceilingY + 40, x - 40, ceilingY + 25);
            }
            ctx.closePath();
            ctx.fill();

            // Gold trim
            ctx.strokeStyle = '#8B7500';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, ceilingY + 25);
            for (let x = 0; x <= w; x += 40) {
                ctx.quadraticCurveTo(x + 20, ceilingY + 40, x + 40, ceilingY + 25);
            }
            ctx.stroke();
        }

        function drawHardwoodFloor(ctx, w, h, floorY) {
            const plankHeight = 20;
            const plankWidth = 80;

            // Floor base with perspective gradient
            const floorGradient = ctx.createLinearGradient(0, floorY, 0, h);
            floorGradient.addColorStop(0, '#3d2817');
            floorGradient.addColorStop(1, '#2a1a0f');
            ctx.fillStyle = floorGradient;
            ctx.fillRect(0, floorY, w, h - floorY);

            // Draw planks
            let row = 0;
            for (let y = floorY; y < h; y += plankHeight) {
                const offset = (row % 2) * (plankWidth / 2);
                for (let x = -plankWidth + offset; x < w; x += plankWidth) {
                    // Plank variation
                    const brightness = 0.9 + Math.random() * 0.2;
                    const r = Math.floor(61 * brightness);
                    const g = Math.floor(40 * brightness);
                    const b = Math.floor(23 * brightness);
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(x, y, plankWidth - 2, plankHeight - 1);

                    // Wood grain
                    ctx.strokeStyle = `rgba(0, 0, 0, 0.1)`;
                    ctx.lineWidth = 1;
                    for (let g = 0; g < 3; g++) {
                        ctx.beginPath();
                        ctx.moveTo(x, y + 5 + g * 5);
                        ctx.lineTo(x + plankWidth - 2, y + 5 + g * 5);
                        ctx.stroke();
                    }
                }
                row++;
            }
        }

        function drawBackdrop(ctx, w, h, ceilingY, floorY) {
            const curtainWidth = w * 0.12;
            const backdropX = curtainWidth;
            const backdropW = w - curtainWidth * 2;

            // Night sky backdrop
            const skyGradient = ctx.createLinearGradient(0, ceilingY, 0, floorY);
            skyGradient.addColorStop(0, '#0a0a2a');
            skyGradient.addColorStop(0.5, '#1a1a4a');
            skyGradient.addColorStop(1, '#0f0f3a');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(backdropX, ceilingY + 30, backdropW, floorY - ceilingY - 30);

            // Stars on backdrop
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            for (let i = 0; i < 40; i++) {
                const sx = backdropX + (i * 137.5) % backdropW;
                const sy = ceilingY + 50 + (i * 89.3) % ((floorY - ceilingY) * 0.4);
                const size = (i % 3) + 1;
                ctx.beginPath();
                ctx.arc(sx, sy, size * 0.5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Moon
            ctx.fillStyle = 'rgba(255, 255, 220, 0.9)';
            ctx.beginPath();
            ctx.arc(w * 0.7, ceilingY + 80, 25, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTreeProps(ctx, w, h, floorY, colors) {
            const curtainWidth = w * 0.12;
            const treePositions = [
                { x: curtainWidth + w * 0.08, scale: 0.9 },
                { x: curtainWidth + w * 0.18, scale: 1.1 },
                { x: w - curtainWidth - w * 0.08, scale: 0.85 },
                { x: w - curtainWidth - w * 0.18, scale: 1.0 },
            ];

            treePositions.forEach((tree, idx) => {
                const treeH = h * 0.35 * tree.scale;
                const treeW = treeH * 0.35;
                const x = tree.x;
                const y = floorY;

                // Determine which light affects this tree
                const isLeft = idx < 2;
                const lightColor = isLeft ? colors.left : colors.right;

                // Tree base color (dark green)
                const baseR = 20, baseG = 40, baseB = 25;

                // Trunk with lighting
                const trunkLight = 0.3;
                ctx.fillStyle = `rgb(${40 + lightColor[0] * trunkLight * 0.3}, ${30 + lightColor[1] * trunkLight * 0.1}, ${20 + lightColor[2] * trunkLight * 0.1})`;
                ctx.fillRect(x - treeW * 0.08, y - treeH * 0.25, treeW * 0.16, treeH * 0.25);

                // Foliage layers with front lighting
                for (let i = 0; i < 4; i++) {
                    const layerY = y - treeH * 0.2 - i * treeH * 0.2;
                    const layerW = treeW * (1 - i * 0.15);

                    // Lit side (front)
                    const lightIntensity = 0.4 - i * 0.05;
                    const r = Math.min(255, baseR + lightColor[0] * lightIntensity);
                    const g = Math.min(255, baseG + lightColor[1] * lightIntensity);
                    const b = Math.min(255, baseB + lightColor[2] * lightIntensity);

                    ctx.fillStyle = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
                    ctx.beginPath();
                    ctx.moveTo(x - layerW, layerY);
                    ctx.lineTo(x, layerY - treeH * 0.25);
                    ctx.lineTo(x + layerW, layerY);
                    ctx.closePath();
                    ctx.fill();

                    // Highlight edge
                    ctx.strokeStyle = `rgba(${lightColor[0]}, ${lightColor[1]}, ${lightColor[2]}, 0.3)`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
        }

        // ===== SPOTLIGHT RENDERING =====
        function drawSpotlight(ctx, x, y, targetX, targetY, color, intensity = 1) {
            const rgb = color;
            const spreadAngle = 0.3;
            const length = Math.sqrt((targetX - x) ** 2 + (targetY - y) ** 2);
            const angle = Math.atan2(targetY - y, targetX - x);

            // Light beam
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';

            const gradient = ctx.createRadialGradient(
                targetX, targetY, 0,
                targetX, targetY, length * 0.6
            );
            gradient.addColorStop(0, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.6 * intensity})`);
            gradient.addColorStop(0.3, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 * intensity})`);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');

            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(
                targetX + Math.cos(angle + spreadAngle) * length * 0.5,
                targetY + Math.sin(angle + spreadAngle) * length * 0.3
            );
            ctx.lineTo(
                targetX + Math.cos(angle - spreadAngle) * length * 0.5,
                targetY + Math.sin(angle - spreadAngle) * length * 0.3
            );
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Ground pool of light
            const poolGradient = ctx.createRadialGradient(
                targetX, targetY, 0,
                targetX, targetY, length * 0.4
            );
            poolGradient.addColorStop(0, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 * intensity})`);
            poolGradient.addColorStop(0.5, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.2 * intensity})`);
            poolGradient.addColorStop(1, 'rgba(0,0,0,0)');

            ctx.beginPath();
            ctx.ellipse(targetX, targetY + 20, length * 0.35, length * 0.15, 0, 0, Math.PI * 2);
            ctx.fillStyle = poolGradient;
            ctx.fill();

            ctx.restore();
        }

        function drawSpotlightFixture(ctx, x, y, color) {
            // Housing
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.ellipse(x, y, 15, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Lens glow
            ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, 0.8)`;
            ctx.beginPath();
            ctx.arc(x, y + 5, 8, 0, Math.PI * 2);
            ctx.fill();

            // Lens highlight
            ctx.fillStyle = `rgba(255, 255, 255, 0.3)`;
            ctx.beginPath();
            ctx.arc(x - 2, y + 3, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        // ===== MAIN SCENE =====
        function drawScene() {
            const w = stage.width;
            const h = stage.height;
            const ceilingY = h * 0.12;
            const floorY = h * 0.78;

            // Clear canvas
            stageCtx.fillStyle = '#000';
            stageCtx.fillRect(0, 0, w, h);

            // Get current colors
            const mainColor = hslToRgb(selectedHue, 100, 50);
            const harmony = getHarmonyColors(selectedHue, harmonyType);
            const leftColor = harmony.left[0];
            const rightColor = harmony.right[0];

            // Draw backdrop (behind everything)
            drawBackdrop(stageCtx, w, h, ceilingY, floorY);

            // Draw spotlight beams onto stage (front lighting effect)
            // Spotlights shine from ceiling onto the floor/trees
            const curtainWidth = w * 0.12;
            drawSpotlight(stageCtx, w * 0.25, ceilingY + 10, curtainWidth + w * 0.12, floorY - 30, leftColor, 0.9);
            drawSpotlight(stageCtx, w * 0.5, ceilingY + 5, w * 0.5, floorY - 20, mainColor, 1.2);
            drawSpotlight(stageCtx, w * 0.75, ceilingY + 10, w - curtainWidth - w * 0.12, floorY - 30, rightColor, 0.9);

            // Draw tree props (illuminated by front lights)
            drawTreeProps(stageCtx, w, h, floorY, { main: mainColor, left: leftColor, right: rightColor });

            // Draw hardwood floor
            drawHardwoodFloor(stageCtx, w, h, floorY);

            // Draw floor light pools
            stageCtx.save();
            stageCtx.globalCompositeOperation = 'lighter';

            // Left pool
            const leftPoolGrad = stageCtx.createRadialGradient(curtainWidth + w * 0.12, floorY + 10, 0, curtainWidth + w * 0.12, floorY + 10, w * 0.15);
            leftPoolGrad.addColorStop(0, `rgba(${leftColor[0]}, ${leftColor[1]}, ${leftColor[2]}, 0.3)`);
            leftPoolGrad.addColorStop(1, 'rgba(0,0,0,0)');
            stageCtx.fillStyle = leftPoolGrad;
            stageCtx.fillRect(0, floorY, w, h - floorY);

            // Center pool
            const centerPoolGrad = stageCtx.createRadialGradient(w * 0.5, floorY + 10, 0, w * 0.5, floorY + 10, w * 0.18);
            centerPoolGrad.addColorStop(0, `rgba(${mainColor[0]}, ${mainColor[1]}, ${mainColor[2]}, 0.35)`);
            centerPoolGrad.addColorStop(1, 'rgba(0,0,0,0)');
            stageCtx.fillStyle = centerPoolGrad;
            stageCtx.fillRect(0, floorY, w, h - floorY);

            // Right pool
            const rightPoolGrad = stageCtx.createRadialGradient(w - curtainWidth - w * 0.12, floorY + 10, 0, w - curtainWidth - w * 0.12, floorY + 10, w * 0.15);
            rightPoolGrad.addColorStop(0, `rgba(${rightColor[0]}, ${rightColor[1]}, ${rightColor[2]}, 0.3)`);
            rightPoolGrad.addColorStop(1, 'rgba(0,0,0,0)');
            stageCtx.fillStyle = rightPoolGrad;
            stageCtx.fillRect(0, floorY, w, h - floorY);

            stageCtx.restore();

            // Draw curtains (in front of backdrop, beside stage)
            drawCurtains(stageCtx, w, h, ceilingY, floorY);

            // Draw ceiling with lighting rig
            drawCeiling(stageCtx, w, h, ceilingY);

            // Spotlight fixtures on ceiling
            drawSpotlightFixture(stageCtx, w * 0.25, ceilingY - 15, leftColor);
            drawSpotlightFixture(stageCtx, w * 0.5, ceilingY - 18, mainColor);
            drawSpotlightFixture(stageCtx, w * 0.75, ceilingY - 15, rightColor);

            // Update swatches
            document.getElementById('main-swatch').style.backgroundColor = rgbToString(mainColor);
            document.getElementById('left-swatch').style.backgroundColor = rgbToString(leftColor);
            document.getElementById('right-swatch').style.backgroundColor = rgbToString(rightColor);
        }

        // ===== EVENT HANDLERS =====
        function handleWheelInteraction(e) {
            const rect = wheel.getBoundingClientRect();
            const x = e.clientX - rect.left - 75;
            const y = e.clientY - rect.top - 75;
            const dist = Math.sqrt(x * x + y * y);

            if (dist <= 70) {
                selectedHue = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
                selectedSat = Math.min(100, (dist / 70) * 100);
                updateSelector();
                drawScene();
            }
        }

        let isDragging = false;

        wheel.addEventListener('mousedown', (e) => {
            isDragging = true;
            handleWheelInteraction(e);
        });

        window.addEventListener('mousemove', (e) => {
            if (isDragging) handleWheelInteraction(e);
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Touch support
        wheel.addEventListener('touchstart', (e) => {
            isDragging = true;
            handleWheelInteraction(e.touches[0]);
        });

        wheel.addEventListener('touchmove', (e) => {
            if (isDragging) {
                e.preventDefault();
                handleWheelInteraction(e.touches[0]);
            }
        });

        wheel.addEventListener('touchend', () => {
            isDragging = false;
        });

        // Harmony buttons
        document.querySelectorAll('.harmony-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.harmony-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                harmonyType = btn.dataset.harmony;
                drawScene();
            });
        });

        // ===== INITIALIZATION =====
        window.addEventListener('resize', resizeStage);
        resizeStage();
        drawColorWheel();
        updateSelector();
        drawScene();
    </script>
</body>
</html>
