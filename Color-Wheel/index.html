<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Wheel - Stage Lighting</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            background: #0a0a0f;
            font-family: 'Times New Roman', Times, serif;
            overflow: hidden;
        }

        /* Stage Area */
        #stage-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        #stage {
            width: 100%;
            height: 100%;
        }

        /* Control Panel */
        #control-panel {
            background: linear-gradient(to bottom, #1a1a2e, #0f0f1a);
            border-top: 3px solid #333;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 40px;
            box-shadow: 0 -10px 30px rgba(0,0,0,0.5);
        }

        /* Control Panel Frame */
        .panel-section {
            background: #12121f;
            border: 2px solid #2a2a4a;
            border-radius: 10px;
            padding: 15px;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);
        }
        .panel-label {
            color: #6a6a8a;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
            text-align: center;
        }

        /* RGB Sliders */
        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-width: 180px;
        }
        .slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider-label {
            width: 20px;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
        }
        .slider-label.red { color: #ff4444; }
        .slider-label.green { color: #44ff44; }
        .slider-label.blue { color: #4444ff; }

        .color-slider {
            -webkit-appearance: none;
            appearance: none;
            flex: 1;
            height: 12px;
            border-radius: 6px;
            outline: none;
            cursor: pointer;
        }
        .color-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #333;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .color-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #333;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        #red-slider {
            background: linear-gradient(to right, #000, #ff0000);
        }
        #green-slider {
            background: linear-gradient(to right, #000, #00ff00);
        }
        #blue-slider {
            background: linear-gradient(to right, #000, #0000ff);
        }
        .slider-value {
            width: 36px;
            font-size: 12px;
            color: #aaa;
            text-align: right;
            font-family: 'Times New Roman', Times, serif;
        }
        .color-preview-box {
            width: 100%;
            height: 30px;
            border-radius: 5px;
            border: 2px solid #3a3a5a;
            margin-top: 5px;
        }

        /* Harmony Buttons */
        .harmony-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .harmony-btn {
            background: #1a1a2e;
            border: 1px solid #3a3a5a;
            color: #8a8aaa;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }
        .harmony-btn:hover {
            background: #2a2a4e;
            border-color: #5a5a7a;
        }
        .harmony-btn.active {
            background: #3a3a6e;
            border-color: #7a7aaa;
            color: #fff;
            box-shadow: 0 0 10px rgba(100, 100, 200, 0.3);
        }

        /* Color Preview */
        .color-preview {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .preview-swatch {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            border: 2px solid #3a3a5a;
        }
        #main-swatch { box-shadow: 0 0 15px currentColor; }

        /* LED Indicator */
        .led-strip {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-top: 10px;
        }
        .led {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #333;
        }
        .led.on {
            background: #0f0;
            box-shadow: 0 0 5px #0f0;
        }
    </style>
</head>
<body>
    <div id="stage-container">
        <canvas id="stage"></canvas>
    </div>

    <div id="control-panel">
        <div class="panel-section">
            <div class="panel-label">Main Spotlight - RGB</div>
            <div class="slider-container">
                <div class="slider-row">
                    <span class="slider-label red">R</span>
                    <input type="range" id="red-slider" class="color-slider" min="0" max="255" value="255">
                    <span class="slider-value" id="red-value">255</span>
                </div>
                <div class="slider-row">
                    <span class="slider-label green">G</span>
                    <input type="range" id="green-slider" class="color-slider" min="0" max="255" value="0">
                    <span class="slider-value" id="green-value">0</span>
                </div>
                <div class="slider-row">
                    <span class="slider-label blue">B</span>
                    <input type="range" id="blue-slider" class="color-slider" min="0" max="255" value="0">
                    <span class="slider-value" id="blue-value">0</span>
                </div>
                <div class="color-preview-box" id="main-preview"></div>
            </div>
        </div>

        <div class="panel-section">
            <div class="panel-label">Harmony Mode for Side Spotlights</div>
            <div class="harmony-buttons">
                <button class="harmony-btn active" data-harmony="complementary">Complementary</button>
                <button class="harmony-btn" data-harmony="analogous">Analogous</button>
                <button class="harmony-btn" data-harmony="triadic">Triadic</button>
                <button class="harmony-btn" data-harmony="split">Split-Complementary</button>
            </div>
        </div>

        <div class="panel-section">
            <div class="panel-label">Active Colors</div>
            <div class="color-preview">
                <div class="preview-swatch" id="left-swatch"></div>
                <div class="preview-swatch" id="main-swatch"></div>
                <div class="preview-swatch" id="right-swatch"></div>
            </div>
            <div class="led-strip">
                <div class="led on"></div>
                <div class="led"></div>
                <div class="led on"></div>
            </div>
        </div>
    </div>

    <script>
        // ===== CONFIGURATION =====
        let selectedR = 255;
        let selectedG = 0;
        let selectedB = 0;
        let harmonyType = 'complementary';

        // ===== CANVAS SETUP =====
        const stage = document.getElementById('stage');
        const stageCtx = stage.getContext('2d');

        // RGB Sliders
        const redSlider = document.getElementById('red-slider');
        const greenSlider = document.getElementById('green-slider');
        const blueSlider = document.getElementById('blue-slider');
        const redValue = document.getElementById('red-value');
        const greenValue = document.getElementById('green-value');
        const blueValue = document.getElementById('blue-value');
        const mainPreview = document.getElementById('main-preview');

        function resizeStage() {
            const container = document.getElementById('stage-container');
            stage.width = container.clientWidth;
            stage.height = container.clientHeight;
            drawScene();
        }

        // ===== COLOR UTILITIES =====
        function hslToRgb(h, s, l) {
            s /= 100;
            l /= 100;
            const k = n => (n + h / 30) % 12;
            const a = s * Math.min(l, 1 - l);
            const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
            return [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
        }

        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            return [h * 360, s * 100, l * 100];
        }

        function rgbToString(rgb) {
            return `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
        }

        function getHarmonyColorsFromRgb(r, g, b, type) {
            const [h, s, l] = rgbToHsl(r, g, b);
            const colors = { left: [], right: [] };

            switch(type) {
                case 'complementary':
                    colors.left = [hslToRgb((h + 180) % 360, s, l)];
                    colors.right = [hslToRgb((h + 180) % 360, s, l)];
                    break;
                case 'analogous':
                    colors.left = [hslToRgb((h + 330) % 360, s, l)];
                    colors.right = [hslToRgb((h + 30) % 360, s, l)];
                    break;
                case 'triadic':
                    colors.left = [hslToRgb((h + 120) % 360, s, l)];
                    colors.right = [hslToRgb((h + 240) % 360, s, l)];
                    break;
                case 'split':
                    colors.left = [hslToRgb((h + 150) % 360, s, l)];
                    colors.right = [hslToRgb((h + 210) % 360, s, l)];
                    break;
            }
            return colors;
        }

        function updateSliderDisplay() {
            redValue.textContent = selectedR;
            greenValue.textContent = selectedG;
            blueValue.textContent = selectedB;
            mainPreview.style.backgroundColor = `rgb(${selectedR}, ${selectedG}, ${selectedB})`;
        }

        // ===== STAGE ELEMENTS =====
        function drawCeiling(ctx, w, h, ceilingY) {
            // Ceiling base
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, w, ceilingY);

            // Ceiling panels/beams
            ctx.fillStyle = '#252525';
            const beamWidth = w / 8;
            for (let i = 0; i < 8; i++) {
                ctx.fillRect(i * beamWidth, 0, beamWidth - 2, ceilingY);
            }

            // Lighting rig bar
            ctx.fillStyle = '#333';
            ctx.fillRect(0, ceilingY - 8, w, 8);
            ctx.fillStyle = '#444';
            ctx.fillRect(0, ceilingY - 6, w, 2);
        }

        function drawCurtains(ctx, w, h, ceilingY, floorY) {
            const curtainWidth = w * 0.12;
            const folds = 8;
            const foldWidth = curtainWidth / folds;

            // Left curtain
            for (let i = 0; i < folds; i++) {
                const x = i * foldWidth;
                const shade = i % 2 === 0 ? '#4a1a1a' : '#3a0a0a';
                ctx.fillStyle = shade;
                ctx.beginPath();
                ctx.moveTo(x, ceilingY);
                ctx.lineTo(x + foldWidth, ceilingY);
                ctx.lineTo(x + foldWidth, floorY);
                ctx.lineTo(x, floorY);
                ctx.closePath();
                ctx.fill();
            }

            // Right curtain
            for (let i = 0; i < folds; i++) {
                const x = w - curtainWidth + i * foldWidth;
                const shade = i % 2 === 0 ? '#4a1a1a' : '#3a0a0a';
                ctx.fillStyle = shade;
                ctx.beginPath();
                ctx.moveTo(x, ceilingY);
                ctx.lineTo(x + foldWidth, ceilingY);
                ctx.lineTo(x + foldWidth, floorY);
                ctx.lineTo(x, floorY);
                ctx.closePath();
                ctx.fill();
            }

            // Curtain valance (top drape)
            ctx.fillStyle = '#5a2020';
            ctx.beginPath();
            ctx.moveTo(0, ceilingY);
            ctx.lineTo(w, ceilingY);
            ctx.lineTo(w, ceilingY + 25);
            for (let x = w; x >= 0; x -= 40) {
                ctx.quadraticCurveTo(x - 20, ceilingY + 40, x - 40, ceilingY + 25);
            }
            ctx.closePath();
            ctx.fill();

            // Gold trim
            ctx.strokeStyle = '#8B7500';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, ceilingY + 25);
            for (let x = 0; x <= w; x += 40) {
                ctx.quadraticCurveTo(x + 20, ceilingY + 40, x + 40, ceilingY + 25);
            }
            ctx.stroke();
        }

        function drawHardwoodFloor(ctx, w, h, floorY) {
            const plankHeight = 20;
            const plankWidth = 80;

            // Floor base with perspective gradient
            const floorGradient = ctx.createLinearGradient(0, floorY, 0, h);
            floorGradient.addColorStop(0, '#3d2817');
            floorGradient.addColorStop(1, '#2a1a0f');
            ctx.fillStyle = floorGradient;
            ctx.fillRect(0, floorY, w, h - floorY);

            // Draw planks
            let row = 0;
            for (let y = floorY; y < h; y += plankHeight) {
                const offset = (row % 2) * (plankWidth / 2);
                for (let x = -plankWidth + offset; x < w; x += plankWidth) {
                    // Plank variation
                    const brightness = 0.9 + Math.random() * 0.2;
                    const r = Math.floor(61 * brightness);
                    const g = Math.floor(40 * brightness);
                    const b = Math.floor(23 * brightness);
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(x, y, plankWidth - 2, plankHeight - 1);

                    // Wood grain
                    ctx.strokeStyle = `rgba(0, 0, 0, 0.1)`;
                    ctx.lineWidth = 1;
                    for (let g = 0; g < 3; g++) {
                        ctx.beginPath();
                        ctx.moveTo(x, y + 5 + g * 5);
                        ctx.lineTo(x + plankWidth - 2, y + 5 + g * 5);
                        ctx.stroke();
                    }
                }
                row++;
            }
        }

        function drawBackdrop(ctx, w, h, ceilingY, floorY) {
            const curtainWidth = w * 0.12;
            const backdropX = curtainWidth;
            const backdropW = w - curtainWidth * 2;

            // Night sky backdrop
            const skyGradient = ctx.createLinearGradient(0, ceilingY, 0, floorY);
            skyGradient.addColorStop(0, '#0a0a2a');
            skyGradient.addColorStop(0.5, '#1a1a4a');
            skyGradient.addColorStop(1, '#0f0f3a');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(backdropX, ceilingY + 30, backdropW, floorY - ceilingY - 30);

            // Stars on backdrop
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            for (let i = 0; i < 40; i++) {
                const sx = backdropX + (i * 137.5) % backdropW;
                const sy = ceilingY + 50 + (i * 89.3) % ((floorY - ceilingY) * 0.4);
                const size = (i % 3) + 1;
                ctx.beginPath();
                ctx.arc(sx, sy, size * 0.5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Moon
            ctx.fillStyle = 'rgba(255, 255, 220, 0.9)';
            ctx.beginPath();
            ctx.arc(w * 0.7, ceilingY + 80, 25, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTreeProps(ctx, w, h, floorY, colors) {
            const curtainWidth = w * 0.12;
            // Three trees - one directly under each spotlight
            const treePositions = [
                { x: curtainWidth + w * 0.12, scale: 1.0, color: colors.left },
                { x: w * 0.5, scale: 1.15, color: colors.main },
                { x: w - curtainWidth - w * 0.12, scale: 1.0, color: colors.right },
            ];

            treePositions.forEach((tree) => {
                const treeH = h * 0.4 * tree.scale;
                const treeW = treeH * 0.35;
                const x = tree.x;
                const y = floorY;
                const lightColor = tree.color;

                // Tree base color (dark green)
                const baseR = 20, baseG = 40, baseB = 25;

                // Trunk with lighting
                const trunkLight = 0.3;
                ctx.fillStyle = `rgb(${40 + lightColor[0] * trunkLight * 0.3}, ${30 + lightColor[1] * trunkLight * 0.1}, ${20 + lightColor[2] * trunkLight * 0.1})`;
                ctx.fillRect(x - treeW * 0.08, y - treeH * 0.25, treeW * 0.16, treeH * 0.25);

                // Foliage layers with front lighting
                for (let i = 0; i < 4; i++) {
                    const layerY = y - treeH * 0.2 - i * treeH * 0.2;
                    const layerW = treeW * (1 - i * 0.15);

                    // Lit side (front)
                    const lightIntensity = 0.5 - i * 0.05;
                    const r = Math.min(255, baseR + lightColor[0] * lightIntensity);
                    const g = Math.min(255, baseG + lightColor[1] * lightIntensity);
                    const b = Math.min(255, baseB + lightColor[2] * lightIntensity);

                    ctx.fillStyle = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
                    ctx.beginPath();
                    ctx.moveTo(x - layerW, layerY);
                    ctx.lineTo(x, layerY - treeH * 0.25);
                    ctx.lineTo(x + layerW, layerY);
                    ctx.closePath();
                    ctx.fill();

                    // Highlight edge
                    ctx.strokeStyle = `rgba(${lightColor[0]}, ${lightColor[1]}, ${lightColor[2]}, 0.4)`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
        }

        // ===== SPOTLIGHT RENDERING =====
        function drawSpotlight(ctx, x, y, targetX, targetY, color, intensity = 1) {
            const rgb = color;
            const spreadAngle = 0.3;
            const length = Math.sqrt((targetX - x) ** 2 + (targetY - y) ** 2);
            const angle = Math.atan2(targetY - y, targetX - x);

            // Light beam
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';

            const gradient = ctx.createRadialGradient(
                targetX, targetY, 0,
                targetX, targetY, length * 0.6
            );
            gradient.addColorStop(0, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.6 * intensity})`);
            gradient.addColorStop(0.3, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 * intensity})`);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');

            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(
                targetX + Math.cos(angle + spreadAngle) * length * 0.5,
                targetY + Math.sin(angle + spreadAngle) * length * 0.3
            );
            ctx.lineTo(
                targetX + Math.cos(angle - spreadAngle) * length * 0.5,
                targetY + Math.sin(angle - spreadAngle) * length * 0.3
            );
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Ground pool of light
            const poolGradient = ctx.createRadialGradient(
                targetX, targetY, 0,
                targetX, targetY, length * 0.4
            );
            poolGradient.addColorStop(0, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 * intensity})`);
            poolGradient.addColorStop(0.5, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.2 * intensity})`);
            poolGradient.addColorStop(1, 'rgba(0,0,0,0)');

            ctx.beginPath();
            ctx.ellipse(targetX, targetY + 20, length * 0.35, length * 0.15, 0, 0, Math.PI * 2);
            ctx.fillStyle = poolGradient;
            ctx.fill();

            ctx.restore();
        }

        function drawSpotlightFixture(ctx, x, y, color) {
            // Housing
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.ellipse(x, y, 15, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Lens glow
            ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, 0.8)`;
            ctx.beginPath();
            ctx.arc(x, y + 5, 8, 0, Math.PI * 2);
            ctx.fill();

            // Lens highlight
            ctx.fillStyle = `rgba(255, 255, 255, 0.3)`;
            ctx.beginPath();
            ctx.arc(x - 2, y + 3, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        // ===== MAIN SCENE =====
        function drawScene() {
            const w = stage.width;
            const h = stage.height;
            const ceilingY = h * 0.12;
            const floorY = h * 0.78;

            // Clear canvas
            stageCtx.fillStyle = '#000';
            stageCtx.fillRect(0, 0, w, h);

            // Get current colors from RGB sliders
            const mainColor = [selectedR, selectedG, selectedB];
            const harmony = getHarmonyColorsFromRgb(selectedR, selectedG, selectedB, harmonyType);
            const leftColor = harmony.left[0];
            const rightColor = harmony.right[0];

            // Draw backdrop (behind everything)
            drawBackdrop(stageCtx, w, h, ceilingY, floorY);

            // Draw spotlight beams onto stage (front lighting effect)
            // Spotlights shine from ceiling onto the floor/trees
            const curtainWidth = w * 0.12;
            drawSpotlight(stageCtx, w * 0.25, ceilingY + 10, curtainWidth + w * 0.12, floorY - 30, leftColor, 0.9);
            drawSpotlight(stageCtx, w * 0.5, ceilingY + 5, w * 0.5, floorY - 20, mainColor, 1.2);
            drawSpotlight(stageCtx, w * 0.75, ceilingY + 10, w - curtainWidth - w * 0.12, floorY - 30, rightColor, 0.9);

            // Draw tree props (illuminated by front lights)
            drawTreeProps(stageCtx, w, h, floorY, { main: mainColor, left: leftColor, right: rightColor });

            // Draw hardwood floor
            drawHardwoodFloor(stageCtx, w, h, floorY);

            // Draw floor light pools
            stageCtx.save();
            stageCtx.globalCompositeOperation = 'lighter';

            // Left pool
            const leftPoolGrad = stageCtx.createRadialGradient(curtainWidth + w * 0.12, floorY + 10, 0, curtainWidth + w * 0.12, floorY + 10, w * 0.15);
            leftPoolGrad.addColorStop(0, `rgba(${leftColor[0]}, ${leftColor[1]}, ${leftColor[2]}, 0.3)`);
            leftPoolGrad.addColorStop(1, 'rgba(0,0,0,0)');
            stageCtx.fillStyle = leftPoolGrad;
            stageCtx.fillRect(0, floorY, w, h - floorY);

            // Center pool
            const centerPoolGrad = stageCtx.createRadialGradient(w * 0.5, floorY + 10, 0, w * 0.5, floorY + 10, w * 0.18);
            centerPoolGrad.addColorStop(0, `rgba(${mainColor[0]}, ${mainColor[1]}, ${mainColor[2]}, 0.35)`);
            centerPoolGrad.addColorStop(1, 'rgba(0,0,0,0)');
            stageCtx.fillStyle = centerPoolGrad;
            stageCtx.fillRect(0, floorY, w, h - floorY);

            // Right pool
            const rightPoolGrad = stageCtx.createRadialGradient(w - curtainWidth - w * 0.12, floorY + 10, 0, w - curtainWidth - w * 0.12, floorY + 10, w * 0.15);
            rightPoolGrad.addColorStop(0, `rgba(${rightColor[0]}, ${rightColor[1]}, ${rightColor[2]}, 0.3)`);
            rightPoolGrad.addColorStop(1, 'rgba(0,0,0,0)');
            stageCtx.fillStyle = rightPoolGrad;
            stageCtx.fillRect(0, floorY, w, h - floorY);

            stageCtx.restore();

            // Draw curtains (in front of backdrop, beside stage)
            drawCurtains(stageCtx, w, h, ceilingY, floorY);

            // Draw ceiling with lighting rig
            drawCeiling(stageCtx, w, h, ceilingY);

            // Spotlight fixtures on ceiling
            drawSpotlightFixture(stageCtx, w * 0.25, ceilingY - 15, leftColor);
            drawSpotlightFixture(stageCtx, w * 0.5, ceilingY - 18, mainColor);
            drawSpotlightFixture(stageCtx, w * 0.75, ceilingY - 15, rightColor);

            // Update swatches
            document.getElementById('main-swatch').style.backgroundColor = rgbToString(mainColor);
            document.getElementById('left-swatch').style.backgroundColor = rgbToString(leftColor);
            document.getElementById('right-swatch').style.backgroundColor = rgbToString(rightColor);
        }

        // ===== EVENT HANDLERS =====
        function handleSliderChange() {
            selectedR = parseInt(redSlider.value);
            selectedG = parseInt(greenSlider.value);
            selectedB = parseInt(blueSlider.value);
            updateSliderDisplay();
            drawScene();
        }

        redSlider.addEventListener('input', handleSliderChange);
        greenSlider.addEventListener('input', handleSliderChange);
        blueSlider.addEventListener('input', handleSliderChange);

        // Harmony buttons
        document.querySelectorAll('.harmony-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.harmony-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                harmonyType = btn.dataset.harmony;
                drawScene();
            });
        });

        // ===== INITIALIZATION =====
        window.addEventListener('resize', resizeStage);
        resizeStage();
        updateSliderDisplay();
        drawScene();
    </script>
</body>
</html>
