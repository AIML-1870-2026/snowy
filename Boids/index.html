<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boids - Ant Colony</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #c4a574;
        }

        canvas {
            display: block;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #2d1b0e;
            padding: 20px;
            border-radius: 12px;
            color: #f4e4bc;
            min-width: 220px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }

        .controls h2 {
            margin-bottom: 15px;
            font-size: 18px;
            text-align: center;
            border-bottom: 1px solid rgba(244, 228, 188, 0.3);
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 13px;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(244, 228, 188, 0.3);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #f4e4bc;
            cursor: pointer;
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #f4e4bc;
            cursor: pointer;
            border: none;
        }

        .buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .buttons button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: #f4e4bc;
            color: #2d1b0e;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .buttons button:hover {
            opacity: 0.9;
        }

        .presets {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(244, 228, 188, 0.3);
        }

        .presets h3 {
            font-size: 13px;
            margin-bottom: 10px;
            text-align: center;
            font-weight: 500;
        }

        .preset-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .preset-buttons button {
            padding: 8px 12px;
            border: 1px solid rgba(244, 228, 188, 0.4);
            border-radius: 6px;
            background: transparent;
            color: #f4e4bc;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s;
        }

        .preset-buttons button:hover {
            background: rgba(244, 228, 188, 0.15);
            border-color: rgba(244, 228, 188, 0.6);
        }

        .toggle-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #2d1b0e;
            color: #f4e4bc;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            display: none;
            z-index: 101;
        }

        .stats {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: #2d1b0e;
            padding: 12px 16px;
            border-radius: 10px;
            color: #f4e4bc;
            font-size: 12px;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            z-index: 100;
            min-width: 160px;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
        }

        .stats-label {
            opacity: 0.7;
        }

        .stats-value {
            font-weight: 600;
        }

        @media (max-width: 600px) {
            .controls {
                top: 60px;
                right: 10px;
                left: 10px;
                min-width: auto;
            }

            .controls.hidden {
                display: none;
            }

            .toggle-btn {
                display: block;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="stats">
        <div class="stats-row">
            <span class="stats-label">FPS</span>
            <span class="stats-value" id="statsFps">0</span>
        </div>
        <div class="stats-row">
            <span class="stats-label">Boids</span>
            <span class="stats-value" id="statsBoids">0</span>
        </div>
        <div class="stats-row">
            <span class="stats-label">Avg Speed</span>
            <span class="stats-value" id="statsSpeed">0.0</span>
        </div>
        <div class="stats-row">
            <span class="stats-label">Avg Neighbors</span>
            <span class="stats-value" id="statsNeighbors">0.0</span>
        </div>
    </div>

    <button class="toggle-btn" onclick="toggleControls()">Controls</button>

    <div class="controls" id="controls">
        <h2>Ant Colony</h2>

        <div class="control-group">
            <label>
                <span>Separation</span>
                <span id="separationVal">1.5</span>
            </label>
            <input type="range" id="separation" min="0" max="5" step="0.1" value="1.5">
        </div>

        <div class="control-group">
            <label>
                <span>Alignment</span>
                <span id="alignmentVal">1.0</span>
            </label>
            <input type="range" id="alignment" min="0" max="5" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label>
                <span>Cohesion</span>
                <span id="cohesionVal">1.0</span>
            </label>
            <input type="range" id="cohesion" min="0" max="5" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label>
                <span>Neighbor Radius</span>
                <span id="radiusVal">50</span>
            </label>
            <input type="range" id="radius" min="20" max="200" step="5" value="50">
        </div>

        <div class="control-group">
            <label>
                <span>Boid Count</span>
                <span id="countVal">100</span>
            </label>
            <input type="range" id="count" min="10" max="500" step="10" value="100">
        </div>

        <div class="buttons">
            <button onclick="resetDefaults()">Reset</button>
            <button onclick="togglePause()" id="pauseBtn">Pause</button>
        </div>

        <div class="presets">
            <h3>Presets</h3>
            <div class="preset-buttons">
                <button onclick="applyPreset('schooling')">Schooling</button>
                <button onclick="applyPreset('chaotic')">Chaotic Swarm</button>
                <button onclick="applyPreset('cluster')">Tight Cluster</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let boids = [];
        let paused = false;

        // Stats tracking
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;
        let totalNeighbors = 0;

        // Dirt texture canvas
        let dirtCanvas;
        let dirtCtx;

        // Footprint trails
        const footprints = [];
        const footprintLifetime = 3000; // 3 seconds
        const footprintInterval = 8; // frames between footprints

        // Default settings
        const defaults = {
            separation: 1.5,
            alignment: 1.0,
            cohesion: 1.0,
            radius: 50,
            count: 100
        };

        // Behavior presets
        const presets = {
            schooling: {
                separation: 0.8,
                alignment: 4.0,
                cohesion: 2.0,
                radius: 80
            },
            chaotic: {
                separation: 0.5,
                alignment: 0.3,
                cohesion: 0.3,
                radius: 25
            },
            cluster: {
                separation: 2.0,
                alignment: 1.0,
                cohesion: 4.5,
                radius: 100
            }
        };

        // Current settings
        let settings = { ...defaults };

        // Boid constants
        const maxSpeed = 4;
        const maxForce = 0.1;

        class Boid {
            constructor(x, y) {
                this.position = { x, y };
                this.velocity = {
                    x: (Math.random() - 0.5) * 2,
                    y: (Math.random() - 0.5) * 2
                };
                this.acceleration = { x: 0, y: 0 };
                this.frameCount = Math.floor(Math.random() * footprintInterval);
            }

            edges() {
                if (this.position.x > width) this.position.x = 0;
                if (this.position.x < 0) this.position.x = width;
                if (this.position.y > height) this.position.y = 0;
                if (this.position.y < 0) this.position.y = height;
            }

            getNeighbors(boids, radius) {
                const neighbors = [];
                for (const other of boids) {
                    if (other === this) continue;
                    const d = this.distance(other);
                    if (d < radius) {
                        neighbors.push({ boid: other, distance: d });
                    }
                }
                return neighbors;
            }

            distance(other) {
                const dx = this.position.x - other.position.x;
                const dy = this.position.y - other.position.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            separation(neighbors) {
                const steering = { x: 0, y: 0 };
                let count = 0;

                for (const { boid, distance } of neighbors) {
                    if (distance < settings.radius * 0.5) {
                        const diff = {
                            x: this.position.x - boid.position.x,
                            y: this.position.y - boid.position.y
                        };
                        if (distance > 0) {
                            diff.x /= distance * distance;
                            diff.y /= distance * distance;
                        }
                        steering.x += diff.x;
                        steering.y += diff.y;
                        count++;
                    }
                }

                if (count > 0) {
                    steering.x /= count;
                    steering.y /= count;
                    const mag = Math.sqrt(steering.x * steering.x + steering.y * steering.y);
                    if (mag > 0) {
                        steering.x = (steering.x / mag) * maxSpeed - this.velocity.x;
                        steering.y = (steering.y / mag) * maxSpeed - this.velocity.y;
                        this.limit(steering, maxForce);
                    }
                }

                return steering;
            }

            alignment(neighbors) {
                const steering = { x: 0, y: 0 };

                if (neighbors.length === 0) return steering;

                for (const { boid } of neighbors) {
                    steering.x += boid.velocity.x;
                    steering.y += boid.velocity.y;
                }

                steering.x /= neighbors.length;
                steering.y /= neighbors.length;

                const mag = Math.sqrt(steering.x * steering.x + steering.y * steering.y);
                if (mag > 0) {
                    steering.x = (steering.x / mag) * maxSpeed - this.velocity.x;
                    steering.y = (steering.y / mag) * maxSpeed - this.velocity.y;
                    this.limit(steering, maxForce);
                }

                return steering;
            }

            cohesion(neighbors) {
                const steering = { x: 0, y: 0 };

                if (neighbors.length === 0) return steering;

                const center = { x: 0, y: 0 };
                for (const { boid } of neighbors) {
                    center.x += boid.position.x;
                    center.y += boid.position.y;
                }

                center.x /= neighbors.length;
                center.y /= neighbors.length;

                steering.x = center.x - this.position.x;
                steering.y = center.y - this.position.y;

                const mag = Math.sqrt(steering.x * steering.x + steering.y * steering.y);
                if (mag > 0) {
                    steering.x = (steering.x / mag) * maxSpeed - this.velocity.x;
                    steering.y = (steering.y / mag) * maxSpeed - this.velocity.y;
                    this.limit(steering, maxForce);
                }

                return steering;
            }

            limit(vec, max) {
                const mag = Math.sqrt(vec.x * vec.x + vec.y * vec.y);
                if (mag > max) {
                    vec.x = (vec.x / mag) * max;
                    vec.y = (vec.y / mag) * max;
                }
            }

            flock(boids) {
                const neighbors = this.getNeighbors(boids, settings.radius);
                this.neighborCount = neighbors.length;

                const sep = this.separation(neighbors);
                const ali = this.alignment(neighbors);
                const coh = this.cohesion(neighbors);

                sep.x *= settings.separation;
                sep.y *= settings.separation;
                ali.x *= settings.alignment;
                ali.y *= settings.alignment;
                coh.x *= settings.cohesion;
                coh.y *= settings.cohesion;

                this.acceleration.x += sep.x + ali.x + coh.x;
                this.acceleration.y += sep.y + ali.y + coh.y;
            }

            getSpeed() {
                return Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
            }

            update() {
                this.velocity.x += this.acceleration.x;
                this.velocity.y += this.acceleration.y;

                const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
                if (speed > maxSpeed) {
                    this.velocity.x = (this.velocity.x / speed) * maxSpeed;
                    this.velocity.y = (this.velocity.y / speed) * maxSpeed;
                }

                this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;

                this.acceleration.x = 0;
                this.acceleration.y = 0;

                // Add footprints periodically
                this.frameCount++;
                if (this.frameCount >= footprintInterval) {
                    this.frameCount = 0;
                    const angle = Math.atan2(this.velocity.y, this.velocity.x);
                    footprints.push({
                        x: this.position.x,
                        y: this.position.y,
                        angle: angle,
                        time: performance.now()
                    });
                }
            }

            draw() {
                const angle = Math.atan2(this.velocity.y, this.velocity.x);

                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                ctx.rotate(angle);

                const antColor = '#2d1b0e';
                const legColor = '#1a1008';

                // Legs (6 total, 3 per side)
                ctx.strokeStyle = legColor;
                ctx.lineWidth = 1;

                // Left legs
                ctx.beginPath();
                ctx.moveTo(-2, 0);
                ctx.lineTo(-5, -4);
                ctx.moveTo(0, 0);
                ctx.lineTo(-2, -5);
                ctx.moveTo(2, 0);
                ctx.lineTo(1, -4);
                ctx.stroke();

                // Right legs
                ctx.beginPath();
                ctx.moveTo(-2, 0);
                ctx.lineTo(-5, 4);
                ctx.moveTo(0, 0);
                ctx.lineTo(-2, 5);
                ctx.moveTo(2, 0);
                ctx.lineTo(1, 4);
                ctx.stroke();

                // Abdomen (back)
                ctx.fillStyle = antColor;
                ctx.beginPath();
                ctx.ellipse(-5, 0, 4, 3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Thorax (middle)
                ctx.beginPath();
                ctx.ellipse(0, 0, 3, 2.5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head (front)
                ctx.beginPath();
                ctx.ellipse(5, 0, 2.5, 2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Antennae
                ctx.strokeStyle = antColor;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(6, -1);
                ctx.quadraticCurveTo(9, -3, 10, -5);
                ctx.moveTo(6, 1);
                ctx.quadraticCurveTo(9, 3, 10, 5);
                ctx.stroke();

                ctx.restore();
            }
        }

        function initBoids() {
            boids = [];
            for (let i = 0; i < settings.count; i++) {
                boids.push(new Boid(
                    Math.random() * width,
                    Math.random() * height
                ));
            }
        }

        function createDirtTexture() {
            dirtCanvas = document.createElement('canvas');
            dirtCanvas.width = width;
            dirtCanvas.height = height;
            dirtCtx = dirtCanvas.getContext('2d');

            // Base dirt color
            dirtCtx.fillStyle = '#c4a574';
            dirtCtx.fillRect(0, 0, width, height);

            // Add noise/grain for dirt texture
            const imageData = dirtCtx.getImageData(0, 0, width, height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                // Random variation for each pixel
                const noise = (Math.random() - 0.5) * 40;
                const darkSpot = Math.random() < 0.02 ? -30 : 0; // Occasional dark spots
                const lightSpot = Math.random() < 0.01 ? 20 : 0; // Occasional pebbles

                data[i] = Math.max(0, Math.min(255, data[i] + noise + darkSpot + lightSpot));     // R
                data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise + darkSpot + lightSpot)); // G
                data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise * 0.7 + darkSpot)); // B (less variation)
            }

            dirtCtx.putImageData(imageData, 0, 0);

            // Add some larger dirt clumps
            for (let i = 0; i < width * height / 5000; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const radius = Math.random() * 3 + 1;
                const shade = Math.random() < 0.5 ? 'rgba(90, 70, 50, 0.3)' : 'rgba(180, 160, 130, 0.3)';
                dirtCtx.beginPath();
                dirtCtx.arc(x, y, radius, 0, Math.PI * 2);
                dirtCtx.fillStyle = shade;
                dirtCtx.fill();
            }
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            createDirtTexture();
        }

        function drawFootprints() {
            const now = performance.now();

            // Remove old footprints
            while (footprints.length > 0 && now - footprints[0].time > footprintLifetime) {
                footprints.shift();
            }

            // Draw remaining footprints
            for (const print of footprints) {
                const age = now - print.time;
                const alpha = 1 - (age / footprintLifetime);

                ctx.save();
                ctx.translate(print.x, print.y);
                ctx.rotate(print.angle);
                ctx.globalAlpha = alpha * 0.7;

                // Draw 6 tiny dots for ant footprints (3 per side)
                ctx.fillStyle = '#2a1a0a';

                // Left side prints
                ctx.beginPath();
                ctx.arc(-3, -3, 0.8, 0, Math.PI * 2);
                ctx.arc(0, -3.5, 0.8, 0, Math.PI * 2);
                ctx.arc(3, -3, 0.8, 0, Math.PI * 2);
                ctx.fill();

                // Right side prints
                ctx.beginPath();
                ctx.arc(-3, 3, 0.8, 0, Math.PI * 2);
                ctx.arc(0, 3.5, 0.8, 0, Math.PI * 2);
                ctx.arc(3, 3, 0.8, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        function updateBoidCount() {
            const diff = settings.count - boids.length;
            if (diff > 0) {
                for (let i = 0; i < diff; i++) {
                    boids.push(new Boid(
                        Math.random() * width,
                        Math.random() * height
                    ));
                }
            } else if (diff < 0) {
                boids.splice(settings.count);
            }
        }

        function animate() {
            // FPS calculation
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
            }

            if (!paused) {
                // Draw dirt background
                if (dirtCanvas) {
                    ctx.drawImage(dirtCanvas, 0, 0);
                } else {
                    ctx.fillStyle = '#c4a574';
                    ctx.fillRect(0, 0, width, height);
                }

                // Draw fading footprints
                drawFootprints();

                for (const boid of boids) {
                    boid.flock(boids);
                }

                let totalSpeed = 0;
                let totalNeighbors = 0;

                for (const boid of boids) {
                    boid.update();
                    boid.edges();
                    boid.draw();
                    totalSpeed += boid.getSpeed();
                    totalNeighbors += boid.neighborCount || 0;
                }

                // Update stats display
                const avgSpeed = boids.length > 0 ? totalSpeed / boids.length : 0;
                const avgNeighbors = boids.length > 0 ? totalNeighbors / boids.length : 0;

                document.getElementById('statsFps').textContent = fps;
                document.getElementById('statsBoids').textContent = boids.length;
                document.getElementById('statsSpeed').textContent = avgSpeed.toFixed(1);
                document.getElementById('statsNeighbors').textContent = avgNeighbors.toFixed(1);
            }

            requestAnimationFrame(animate);
        }

        // Control handlers
        function setupControls() {
            const controls = ['separation', 'alignment', 'cohesion', 'radius', 'count'];

            controls.forEach(name => {
                const input = document.getElementById(name);
                const display = document.getElementById(name + 'Val');

                input.addEventListener('input', () => {
                    const value = parseFloat(input.value);
                    settings[name] = value;
                    display.textContent = value.toFixed(name === 'radius' || name === 'count' ? 0 : 1);

                    if (name === 'count') {
                        updateBoidCount();
                    }
                });
            });
        }

        function resetDefaults() {
            settings = { ...defaults };

            document.getElementById('separation').value = defaults.separation;
            document.getElementById('separationVal').textContent = defaults.separation.toFixed(1);

            document.getElementById('alignment').value = defaults.alignment;
            document.getElementById('alignmentVal').textContent = defaults.alignment.toFixed(1);

            document.getElementById('cohesion').value = defaults.cohesion;
            document.getElementById('cohesionVal').textContent = defaults.cohesion.toFixed(1);

            document.getElementById('radius').value = defaults.radius;
            document.getElementById('radiusVal').textContent = defaults.radius;

            document.getElementById('count').value = defaults.count;
            document.getElementById('countVal').textContent = defaults.count;

            initBoids();
        }

        function togglePause() {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Play' : 'Pause';
        }

        function applyPreset(presetName) {
            const preset = presets[presetName];
            if (!preset) return;

            // Apply preset values (keep current count)
            settings.separation = preset.separation;
            settings.alignment = preset.alignment;
            settings.cohesion = preset.cohesion;
            settings.radius = preset.radius;

            // Update UI
            document.getElementById('separation').value = preset.separation;
            document.getElementById('separationVal').textContent = preset.separation.toFixed(1);

            document.getElementById('alignment').value = preset.alignment;
            document.getElementById('alignmentVal').textContent = preset.alignment.toFixed(1);

            document.getElementById('cohesion').value = preset.cohesion;
            document.getElementById('cohesionVal').textContent = preset.cohesion.toFixed(1);

            document.getElementById('radius').value = preset.radius;
            document.getElementById('radiusVal').textContent = preset.radius;
        }

        function toggleControls() {
            document.getElementById('controls').classList.toggle('hidden');
        }

        // Initialize
        window.addEventListener('resize', resize);
        resize();
        setupControls();
        initBoids();
        animate();
    </script>
</body>
</html>
