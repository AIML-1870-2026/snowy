<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monkey Jumper - Jungle Runner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(to bottom, #1a3a1a, #0d1f0d);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
            border: 4px solid #4a2c0a;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #gameCanvas {
            display: block;
            background: #87CEEB;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.7);
            color: white;
            text-align: center;
        }
        #overlay.hidden {
            display: none;
        }
        #overlay h1 {
            font-size: 48px;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }
        #overlay h2 {
            font-size: 32px;
            color: #FF6B6B;
            margin-bottom: 10px;
        }
        #overlay p {
            font-size: 20px;
            margin: 10px 0;
        }
        #overlay .score-display {
            font-size: 24px;
            color: #90EE90;
            margin: 5px 0;
        }
        #overlay .high-score {
            color: #FFD700;
        }
        #overlay .new-record {
            color: #FF69B4;
            font-size: 28px;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }
        #overlay .instructions {
            font-size: 16px;
            color: #ccc;
            margin-top: 20px;
        }
        #startBtn, #restartBtn {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(to bottom, #4CAF50, #2E7D32);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        #startBtn:hover, #restartBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.4);
        }
        #startBtn:active, #restartBtn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        <div id="ui">
            <span id="scoreDisplay">Score: 0</span>
            <span id="highScoreDisplay">High Score: 0</span>
        </div>
        <div id="overlay">
            <h1>üêµ MONKEY JUMPER üêµ</h1>
            <p>Help the monkey escape through the jungle!</p>
            <p class="instructions">Press SPACE to jump over snakes</p>
            <p class="instructions">Collect bananas for bonus points!</p>
            <p class="score-display high-score" id="menuHighScore">High Score: 0</p>
            <button id="startBtn">START GAME</button>
        </div>
    </div>

    <script>
        // ============================================
        // PATTERN CHUNK 1: Game Canvas
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;
        const GROUND_Y = CANVAS_HEIGHT - 60;

        // ============================================
        // PATTERN CHUNK 11: Audio Manager
        // ============================================
        const AudioManager = {
            jumpSound: null,
            collectSound: null,
            initialized: false,

            init() {
                if (this.initialized) return;

                // Create jump sound using oscillator
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.initialized = true;
            },

            playJump() {
                if (!this.initialized) this.init();

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(600, this.audioContext.currentTime + 0.1);

                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.2);
            },

            playCollect() {
                if (!this.initialized) this.init();

                // Monkey "ooh ooh" sound - two quick chirps
                const time = this.audioContext.currentTime;

                // First chirp "ooh"
                const osc1 = this.audioContext.createOscillator();
                const gain1 = this.audioContext.createGain();
                osc1.connect(gain1);
                gain1.connect(this.audioContext.destination);
                osc1.frequency.setValueAtTime(600, time);
                osc1.frequency.exponentialRampToValueAtTime(900, time + 0.05);
                osc1.frequency.exponentialRampToValueAtTime(500, time + 0.1);
                gain1.gain.setValueAtTime(0.25, time);
                gain1.gain.exponentialRampToValueAtTime(0.01, time + 0.12);
                osc1.start(time);
                osc1.stop(time + 0.12);

                // Second chirp "ooh" (higher pitched)
                const osc2 = this.audioContext.createOscillator();
                const gain2 = this.audioContext.createGain();
                osc2.connect(gain2);
                gain2.connect(this.audioContext.destination);
                osc2.frequency.setValueAtTime(700, time + 0.12);
                osc2.frequency.exponentialRampToValueAtTime(1000, time + 0.17);
                osc2.frequency.exponentialRampToValueAtTime(600, time + 0.22);
                gain2.gain.setValueAtTime(0.0001, time);
                gain2.gain.setValueAtTime(0.25, time + 0.12);
                gain2.gain.exponentialRampToValueAtTime(0.01, time + 0.25);
                osc2.start(time + 0.12);
                osc2.stop(time + 0.25);
            }
        };

        // ============================================
        // PATTERN CHUNK 13: High Score Manager
        // ============================================
        const HighScoreManager = {
            key: 'jumper_high_score',

            get() {
                const score = localStorage.getItem(this.key);
                return score ? parseInt(score, 10) : 0;
            },

            set(score) {
                const current = this.get();
                if (score > current) {
                    localStorage.setItem(this.key, score.toString());
                    return true; // New record!
                }
                return false;
            }
        };

        // ============================================
        // PATTERN CHUNK 12: Difficulty Manager
        // ============================================
        const DifficultyManager = {
            baseSpeed: 5,
            baseSpawnRate: 1500,
            currentSpeed: 5,
            currentSpawnRate: 1500,
            level: 1,
            lastLevelUp: 0,
            levelUpInterval: 10000, // 10 seconds

            reset() {
                this.currentSpeed = this.baseSpeed;
                this.currentSpawnRate = this.baseSpawnRate;
                this.level = 1;
                this.lastLevelUp = 0;
            },

            update(elapsedTime) {
                if (elapsedTime - this.lastLevelUp >= this.levelUpInterval) {
                    this.level++;
                    this.currentSpeed = this.baseSpeed + (this.level - 1) * 0.5;
                    this.currentSpawnRate = Math.max(500, this.baseSpawnRate - (this.level - 1) * 100);
                    this.lastLevelUp = elapsedTime;
                    return true; // Level up occurred
                }
                return false;
            }
        };

        // ============================================
        // PATTERN CHUNK 10: Game State Manager
        // ============================================
        const GameState = {
            MENU: 'menu',
            PLAYING: 'playing',
            GAME_OVER: 'gameOver'
        };

        let currentState = GameState.MENU;
        let score = 0;
        let highScore = HighScoreManager.get();
        let isNewRecord = false;
        let gameStartTime = 0;
        let lastTime = 0;

        // ============================================
        // PATTERN CHUNK 3: Player Character (Monkey)
        // ============================================
        const monkey = {
            x: 100,
            y: GROUND_Y,
            width: 50,
            height: 60,
            velocityY: 0,
            isJumping: false,
            isDead: false,
            deathRotation: 0,
            runFrame: 0,
            frameTimer: 0,

            reset() {
                this.y = GROUND_Y - this.height;
                this.velocityY = 0;
                this.isJumping = false;
                this.isDead = false;
                this.deathRotation = 0;
                this.runFrame = 0;
            },

            jump() {
                if (!this.isJumping && !this.isDead) {
                    this.velocityY = -15;
                    this.isJumping = true;
                    AudioManager.playJump();
                }
            },

            update(deltaTime) {
                if (this.isDead) {
                    // Death animation
                    if (this.deathRotation < Math.PI / 2) {
                        this.deathRotation += 0.1;
                    }
                    if (this.y < GROUND_Y - 20) {
                        this.velocityY += 0.8;
                        this.y += this.velocityY;
                    }
                    return;
                }

                // Gravity
                this.velocityY += 0.8;
                this.y += this.velocityY;

                // Ground collision
                if (this.y >= GROUND_Y - this.height) {
                    this.y = GROUND_Y - this.height;
                    this.velocityY = 0;
                    this.isJumping = false;
                }

                // Animation frame
                this.frameTimer += deltaTime;
                if (this.frameTimer > 100) {
                    this.runFrame = (this.runFrame + 1) % 4;
                    this.frameTimer = 0;
                }
            },

            draw() {
                ctx.save();

                if (this.isDead) {
                    ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                    ctx.rotate(this.deathRotation);
                    ctx.translate(-this.width / 2, -this.height / 2);
                } else {
                    ctx.translate(this.x, this.y);
                }

                const legOffset = this.isJumping ? 0 : Math.sin(this.runFrame * Math.PI / 2) * 5;
                const armSwing = this.isJumping ? -10 : Math.sin(this.runFrame * Math.PI / 2) * 8;

                // Tail (behind body)
                ctx.strokeStyle = '#5D4037';
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(8, this.height / 2 + 5);
                ctx.quadraticCurveTo(-15, this.height / 2 + 10, -10, this.height / 2 - 10);
                ctx.quadraticCurveTo(-5, this.height / 2 - 25, 5, this.height / 2 - 20);
                ctx.stroke();

                // Back arm (behind body)
                ctx.fillStyle = '#6D4C41';
                ctx.beginPath();
                ctx.ellipse(this.width / 2 - 18, 38 - armSwing, 6, 14, -0.3, 0, Math.PI * 2);
                ctx.fill();
                // Back hand
                ctx.fillStyle = '#BCAAA4';
                ctx.beginPath();
                ctx.arc(this.width / 2 - 20, 50 - armSwing, 5, 0, Math.PI * 2);
                ctx.fill();

                // Back leg
                ctx.fillStyle = '#6D4C41';
                ctx.beginPath();
                ctx.ellipse(this.width / 2 - 6, this.height - 8 - legOffset, 7, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                // Back foot
                ctx.fillStyle = '#4E342E';
                ctx.beginPath();
                ctx.ellipse(this.width / 2 - 6, this.height - legOffset, 8, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Body (torso) with fur texture
                ctx.fillStyle = '#795548';
                ctx.beginPath();
                ctx.ellipse(this.width / 2, this.height / 2 + 5, 16, 22, 0, 0, Math.PI * 2);
                ctx.fill();

                // Belly (lighter)
                ctx.fillStyle = '#A1887F';
                ctx.beginPath();
                ctx.ellipse(this.width / 2 + 2, this.height / 2 + 8, 10, 14, 0, 0, Math.PI * 2);
                ctx.fill();

                // Front leg
                ctx.fillStyle = '#6D4C41';
                ctx.beginPath();
                ctx.ellipse(this.width / 2 + 6, this.height - 8 + legOffset, 7, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                // Front foot
                ctx.fillStyle = '#4E342E';
                ctx.beginPath();
                ctx.ellipse(this.width / 2 + 8, this.height + legOffset, 8, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = '#6D4C41';
                ctx.beginPath();
                ctx.arc(this.width / 2, 18, 16, 0, Math.PI * 2);
                ctx.fill();

                // Fur tuft on top
                ctx.fillStyle = '#5D4037';
                ctx.beginPath();
                ctx.ellipse(this.width / 2, 4, 8, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Face (muzzle area)
                ctx.fillStyle = '#BCAAA4';
                ctx.beginPath();
                ctx.ellipse(this.width / 2, 22, 11, 9, 0, 0, Math.PI * 2);
                ctx.fill();

                // Ears
                ctx.fillStyle = '#6D4C41';
                ctx.beginPath();
                ctx.arc(this.width / 2 - 14, 14, 7, 0, Math.PI * 2);
                ctx.arc(this.width / 2 + 14, 14, 7, 0, Math.PI * 2);
                ctx.fill();
                // Inner ears
                ctx.fillStyle = '#BCAAA4';
                ctx.beginPath();
                ctx.arc(this.width / 2 - 14, 14, 4, 0, Math.PI * 2);
                ctx.arc(this.width / 2 + 14, 14, 4, 0, Math.PI * 2);
                ctx.fill();

                // Eye sockets
                ctx.fillStyle = '#4E342E';
                ctx.beginPath();
                ctx.ellipse(this.width / 2 - 6, 16, 5, 4, 0, 0, Math.PI * 2);
                ctx.ellipse(this.width / 2 + 6, 16, 5, 4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                ctx.fillStyle = this.isDead ? '#ff0000' : '#FFFFFF';
                ctx.beginPath();
                ctx.arc(this.width / 2 - 6, 16, 3.5, 0, Math.PI * 2);
                ctx.arc(this.width / 2 + 6, 16, 3.5, 0, Math.PI * 2);
                ctx.fill();

                // Pupils
                if (!this.isDead) {
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.arc(this.width / 2 - 5, 16, 2, 0, Math.PI * 2);
                    ctx.arc(this.width / 2 + 7, 16, 2, 0, Math.PI * 2);
                    ctx.fill();
                    // Eye shine
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(this.width / 2 - 4, 15, 1, 0, Math.PI * 2);
                    ctx.arc(this.width / 2 + 8, 15, 1, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // X eyes when dead
                    ctx.strokeStyle = '#1a1a1a';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.width / 2 - 8, 14);
                    ctx.lineTo(this.width / 2 - 4, 18);
                    ctx.moveTo(this.width / 2 - 4, 14);
                    ctx.lineTo(this.width / 2 - 8, 18);
                    ctx.moveTo(this.width / 2 + 4, 14);
                    ctx.lineTo(this.width / 2 + 8, 18);
                    ctx.moveTo(this.width / 2 + 8, 14);
                    ctx.lineTo(this.width / 2 + 4, 18);
                    ctx.stroke();
                }

                // Nose
                ctx.fillStyle = '#4E342E';
                ctx.beginPath();
                ctx.ellipse(this.width / 2, 23, 4, 3, 0, 0, Math.PI * 2);
                ctx.fill();
                // Nostrils
                ctx.fillStyle = '#3E2723';
                ctx.beginPath();
                ctx.arc(this.width / 2 - 1.5, 23, 1, 0, Math.PI * 2);
                ctx.arc(this.width / 2 + 1.5, 23, 1, 0, Math.PI * 2);
                ctx.fill();

                // Mouth
                ctx.strokeStyle = '#5D4037';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                if (this.isDead) {
                    ctx.arc(this.width / 2, 29, 3, 0, Math.PI, true);
                } else {
                    ctx.moveTo(this.width / 2, 26);
                    ctx.lineTo(this.width / 2, 28);
                    ctx.moveTo(this.width / 2 - 4, 29);
                    ctx.quadraticCurveTo(this.width / 2, 31, this.width / 2 + 4, 29);
                }
                ctx.stroke();

                // Front arm
                ctx.fillStyle = '#6D4C41';
                ctx.beginPath();
                ctx.ellipse(this.width / 2 + 18, 38 + armSwing, 6, 14, 0.3, 0, Math.PI * 2);
                ctx.fill();
                // Front hand
                ctx.fillStyle = '#BCAAA4';
                ctx.beginPath();
                ctx.arc(this.width / 2 + 20, 50 + armSwing, 5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            },

            getBounds() {
                return {
                    x: this.x + 10,
                    y: this.y + 10,
                    width: this.width - 20,
                    height: this.height - 10
                };
            }
        };

        // ============================================
        // PATTERN CHUNK 6: Obstacle Spawner (Snakes)
        // ============================================
        let snakes = [];
        let lastSnakeSpawn = 0;
        let nextSnakeDelay = 1500;

        function getRandomSnakeDelay() {
            const baseRate = DifficultyManager.currentSpawnRate;
            // Minimum delay to ensure jump is always possible
            // At speed 5-10, monkey needs ~800ms to complete a jump and land
            const minDelay = 800;

            // Random variance: 70% to 150% of base rate for variety
            const variance = 0.7 + Math.random() * 0.8;
            let delay = baseRate * variance;

            // Occasionally create moderate clusters (15% chance)
            if (Math.random() < 0.15) {
                delay = baseRate * 0.6;
            }
            // Occasionally create longer gaps (20% chance)
            if (Math.random() < 0.20) {
                delay = baseRate * 1.5;
            }

            // Ensure minimum delay for fair gameplay
            return Math.max(minDelay, delay);
        }

        function spawnSnake() {
            snakes.push({
                x: CANVAS_WIDTH + 50,
                y: GROUND_Y - 25,
                width: 60,
                height: 25,
                waveOffset: Math.random() * Math.PI * 2
            });
        }

        function updateSnakes(deltaTime, currentTime) {
            // Spawn new snakes with varied timing
            if (currentTime - lastSnakeSpawn > nextSnakeDelay) {
                spawnSnake();
                lastSnakeSpawn = currentTime;
                nextSnakeDelay = getRandomSnakeDelay();
            }

            // Update positions
            snakes.forEach(snake => {
                snake.x -= DifficultyManager.currentSpeed;
            });

            // Remove off-screen snakes
            snakes = snakes.filter(snake => snake.x > -100);
        }

        function drawSnake(snake) {
            ctx.save();
            ctx.translate(snake.x, snake.y);

            // Body segments (wavy) - Red snake
            ctx.fillStyle = '#CC2222';
            for (let i = 0; i < 5; i++) {
                const segX = i * 12;
                const segY = Math.sin((Date.now() / 200) + snake.waveOffset + i * 0.5) * 3;
                ctx.beginPath();
                ctx.ellipse(segX, segY + 12, 8, 6, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Head
            ctx.fillStyle = '#E53935';
            ctx.beginPath();
            ctx.ellipse(55, 10, 10, 8, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#FFEB3B';
            ctx.beginPath();
            ctx.arc(58, 6, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(59, 6, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Tongue
            ctx.strokeStyle = '#D81B60';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(64, 10);
            ctx.lineTo(70, 8);
            ctx.moveTo(67, 9);
            ctx.lineTo(70, 12);
            ctx.stroke();

            // Pattern on body - darker red diamonds
            ctx.fillStyle = '#8B0000';
            for (let i = 0; i < 4; i++) {
                const segX = i * 12 + 6;
                const segY = Math.sin((Date.now() / 200) + snake.waveOffset + i * 0.5) * 3;
                ctx.beginPath();
                ctx.moveTo(segX, segY + 8);
                ctx.lineTo(segX + 4, segY + 12);
                ctx.lineTo(segX, segY + 16);
                ctx.lineTo(segX - 4, segY + 12);
                ctx.closePath();
                ctx.fill();
            }

            ctx.restore();
        }

        // ============================================
        // PATTERN CHUNK 7: Collectible Spawner (Bananas)
        // ============================================
        let bananas = [];
        let lastBananaSpawn = 0;
        const BANANA_SPAWN_RATE = 2000;

        function spawnBanana() {
            const isAirBanana = Math.random() > 0.5;
            bananas.push({
                x: CANVAS_WIDTH + 30,
                y: isAirBanana ? GROUND_Y - 120 - Math.random() * 50 : GROUND_Y - 40,
                width: 30,
                height: 30,
                rotation: Math.random() * 0.5 - 0.25,
                isAir: isAirBanana
            });
        }

        function updateBananas(deltaTime, currentTime) {
            // Spawn new bananas
            if (currentTime - lastBananaSpawn > BANANA_SPAWN_RATE) {
                if (Math.random() > 0.3) { // 70% chance to spawn
                    spawnBanana();
                }
                lastBananaSpawn = currentTime;
            }

            // Update positions
            bananas.forEach(banana => {
                banana.x -= DifficultyManager.currentSpeed;
            });

            // Remove off-screen bananas
            bananas = bananas.filter(banana => banana.x > -50);
        }

        function drawBanana(banana) {
            ctx.save();
            ctx.translate(banana.x + banana.width / 2, banana.y + banana.height / 2);
            ctx.rotate(banana.rotation + Math.sin(Date.now() / 300) * 0.1);

            // Single banana - curved crescent shape
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            // Outer curve
            ctx.moveTo(-12, 5);
            ctx.quadraticCurveTo(-8, -12, 8, -10);
            ctx.quadraticCurveTo(14, -8, 15, -2);
            // Inner curve
            ctx.quadraticCurveTo(12, -6, 6, -6);
            ctx.quadraticCurveTo(-4, -6, -8, 2);
            ctx.closePath();
            ctx.fill();

            // Darker yellow for depth
            ctx.fillStyle = '#E6BE00';
            ctx.beginPath();
            ctx.moveTo(-10, 3);
            ctx.quadraticCurveTo(-6, -8, 6, -7);
            ctx.quadraticCurveTo(10, -6, 12, -3);
            ctx.quadraticCurveTo(8, -4, 4, -4);
            ctx.quadraticCurveTo(-4, -4, -8, 1);
            ctx.closePath();
            ctx.fill();

            // Stem end (top)
            ctx.fillStyle = '#6B4423';
            ctx.beginPath();
            ctx.arc(14, -3, 2.5, 0, Math.PI * 2);
            ctx.fill();

            // Bottom tip
            ctx.fillStyle = '#4A3015';
            ctx.beginPath();
            ctx.ellipse(-11, 4, 2, 3, 0.5, 0, Math.PI * 2);
            ctx.fill();

            // Highlight shine
            ctx.strokeStyle = 'rgba(255, 255, 240, 0.6)';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-4, -4);
            ctx.quadraticCurveTo(2, -8, 8, -6);
            ctx.stroke();

            ctx.restore();
        }

        // ============================================
        // PATTERN CHUNK 14: River & Platform System
        // ============================================
        let rivers = [];
        let platforms = [];
        let lastRiverSpawn = 0;
        const RIVER_SPAWN_SCORE = 150;
        const RIVER_SPAWN_INTERVAL = 8000; // 8 seconds between rivers

        function spawnRiver() {
            const riverWidth = 200;
            const riverX = CANVAS_WIDTH + 50;

            // Add river
            rivers.push({
                x: riverX,
                width: riverWidth,
                waveOffset: Math.random() * Math.PI * 2
            });

            // Add platform above the river
            platforms.push({
                x: riverX + riverWidth / 2 - 40,
                y: GROUND_Y - 80,
                width: 80,
                height: 20,
                isLog: true
            });
        }

        function updateRivers(deltaTime, currentTime) {
            // Only spawn rivers after score reaches threshold
            if (score >= RIVER_SPAWN_SCORE) {
                if (currentTime - lastRiverSpawn > RIVER_SPAWN_INTERVAL) {
                    spawnRiver();
                    lastRiverSpawn = currentTime;
                }
            }

            // Update river positions
            rivers.forEach(river => {
                river.x -= DifficultyManager.currentSpeed;
            });

            // Update platform positions
            platforms.forEach(platform => {
                platform.x -= DifficultyManager.currentSpeed;
            });

            // Remove off-screen rivers and platforms
            rivers = rivers.filter(river => river.x + river.width > -50);
            platforms = platforms.filter(platform => platform.x + platform.width > -50);
        }

        function drawRiver(river) {
            ctx.save();

            // River water
            const waterGradient = ctx.createLinearGradient(river.x, GROUND_Y, river.x, CANVAS_HEIGHT);
            waterGradient.addColorStop(0, '#1E90FF');
            waterGradient.addColorStop(0.5, '#0066CC');
            waterGradient.addColorStop(1, '#003366');
            ctx.fillStyle = waterGradient;
            ctx.fillRect(river.x, GROUND_Y, river.width, CANVAS_HEIGHT - GROUND_Y);

            // Animated water waves
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 5; i++) {
                const waveY = GROUND_Y + 10 + i * 10;
                ctx.beginPath();
                for (let x = river.x; x < river.x + river.width; x += 10) {
                    const y = waveY + Math.sin((x + Date.now() / 200 + river.waveOffset) * 0.1) * 3;
                    if (x === river.x) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }

            // River banks (edges)
            ctx.fillStyle = '#654321';
            ctx.fillRect(river.x - 5, GROUND_Y, 8, CANVAS_HEIGHT - GROUND_Y);
            ctx.fillRect(river.x + river.width - 3, GROUND_Y, 8, CANVAS_HEIGHT - GROUND_Y);

            // Rocks on edges
            ctx.fillStyle = '#808080';
            ctx.beginPath();
            ctx.arc(river.x, GROUND_Y + 5, 8, 0, Math.PI * 2);
            ctx.arc(river.x + river.width, GROUND_Y + 5, 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawPlatform(platform) {
            ctx.save();
            ctx.translate(platform.x, platform.y);

            if (platform.isLog) {
                // Wooden log platform
                // Main log body
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.ellipse(platform.width / 2, platform.height / 2, platform.width / 2, platform.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Log texture - wood grain
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 1;
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.moveTo(10 + i * 18, 5);
                    ctx.lineTo(10 + i * 18, platform.height - 5);
                    ctx.stroke();
                }

                // Log ends (circles)
                ctx.fillStyle = '#A0522D';
                ctx.beginPath();
                ctx.ellipse(5, platform.height / 2, 6, platform.height / 2 - 2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(platform.width - 5, platform.height / 2, 6, platform.height / 2 - 2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Ring patterns on log ends
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(5, platform.height / 2, 3, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(platform.width - 5, platform.height / 2, 3, 0, Math.PI * 2);
                ctx.stroke();

                // Highlight on top
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.beginPath();
                ctx.ellipse(platform.width / 2, 5, platform.width / 2 - 5, 4, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function isOverRiver(x, width) {
            for (const river of rivers) {
                if (x + width > river.x && x < river.x + river.width) {
                    return river;
                }
            }
            return null;
        }

        function isOnPlatform(monkeyBounds) {
            for (const platform of platforms) {
                // Check if monkey is above and landing on platform
                if (monkeyBounds.x + monkeyBounds.width > platform.x &&
                    monkeyBounds.x < platform.x + platform.width &&
                    monkeyBounds.y + monkeyBounds.height >= platform.y &&
                    monkeyBounds.y + monkeyBounds.height <= platform.y + platform.height + 10 &&
                    monkey.velocityY >= 0) {
                    return platform;
                }
            }
            return null;
        }

        // ============================================
        // PATTERN CHUNK 8: Collision Detection
        // ============================================
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function checkCollisions() {
            const monkeyBounds = monkey.getBounds();

            // Check snake collisions
            for (const snake of snakes) {
                const snakeBounds = {
                    x: snake.x + 10,
                    y: snake.y,
                    width: snake.width - 10,
                    height: snake.height
                };
                if (checkCollision(monkeyBounds, snakeBounds)) {
                    return 'death';
                }
            }

            // Check banana collisions
            for (let i = bananas.length - 1; i >= 0; i--) {
                const banana = bananas[i];
                const bananaBounds = {
                    x: banana.x,
                    y: banana.y,
                    width: banana.width,
                    height: banana.height
                };
                if (checkCollision(monkeyBounds, bananaBounds)) {
                    bananas.splice(i, 1);
                    score += 50;
                    AudioManager.playCollect();
                }
            }

            // Check platform landing (must check before river)
            const platform = isOnPlatform(monkeyBounds);
            if (platform) {
                // Land on platform
                monkey.y = platform.y - monkey.height + 10;
                monkey.velocityY = 0;
                monkey.isJumping = false;
            }

            // Check river collision (only if not on platform and on ground level)
            if (!monkey.isJumping && monkey.y >= GROUND_Y - monkey.height - 5) {
                const river = isOverRiver(monkey.x + 15, monkey.width - 30);
                if (river) {
                    return 'death';
                }
            }

            return null;
        }

        // ============================================
        // PATTERN CHUNK 5: Ground & Scrolling Background
        // ============================================
        let bgOffset = 0;
        let cloudOffset = 0;
        let timeOfDay = 0; // 0 = noon, 1 = sunset, 2 = night, cycles back

        // Color interpolation helper
        function lerpColor(color1, color2, t) {
            const r1 = parseInt(color1.slice(1, 3), 16);
            const g1 = parseInt(color1.slice(3, 5), 16);
            const b1 = parseInt(color1.slice(5, 7), 16);
            const r2 = parseInt(color2.slice(1, 3), 16);
            const g2 = parseInt(color2.slice(3, 5), 16);
            const b2 = parseInt(color2.slice(5, 7), 16);
            const r = Math.round(r1 + (r2 - r1) * t);
            const g = Math.round(g1 + (g2 - g1) * t);
            const b = Math.round(b1 + (b2 - b1) * t);
            return `rgb(${r}, ${g}, ${b})`;
        }

        function getTimeColors() {
            // Day colors
            const dayTop = '#87CEEB';
            const dayBottom = '#E0F6FF';
            const daySun = '#FFD700';
            const dayTreeFar = '#1B4D1B';
            const dayTreeMid = '#228B22';
            const dayGrass = '#4A7C23';
            const dayCloud = 'rgba(255, 255, 255, 0.9)';

            // Sunset colors
            const sunsetTop = '#FF6B35';
            const sunsetBottom = '#FFB347';
            const sunsetSun = '#FF4500';
            const sunsetTreeFar = '#2D1810';
            const sunsetTreeMid = '#3D2817';
            const sunsetGrass = '#4A3520';
            const sunsetCloud = 'rgba(255, 150, 100, 0.8)';

            // Night colors
            const nightTop = '#0C1445';
            const nightBottom = '#1A237E';
            const nightTreeFar = '#0A1510';
            const nightTreeMid = '#0F1F15';
            const nightGrass = '#1A2F1A';
            const nightCloud = 'rgba(50, 50, 80, 0.5)';

            let t = timeOfDay % 3;
            let colors = {};

            if (t < 1) {
                // Day to Sunset
                colors.skyTop = lerpColor(dayTop, sunsetTop, t);
                colors.skyBottom = lerpColor(dayBottom, sunsetBottom, t);
                colors.sun = lerpColor(daySun, sunsetSun, t);
                colors.treeFar = lerpColor(dayTreeFar, sunsetTreeFar, t);
                colors.treeMid = lerpColor(dayTreeMid, sunsetTreeMid, t);
                colors.grass = lerpColor(dayGrass, sunsetGrass, t);
                colors.cloud = t < 0.5 ? dayCloud : sunsetCloud;
                colors.isNight = false;
                colors.sunY = 60 + t * 100;
            } else if (t < 2) {
                // Sunset to Night
                const nt = t - 1;
                colors.skyTop = lerpColor(sunsetTop, nightTop, nt);
                colors.skyBottom = lerpColor(sunsetBottom, nightBottom, nt);
                colors.sun = sunsetSun;
                colors.treeFar = lerpColor(sunsetTreeFar, nightTreeFar, nt);
                colors.treeMid = lerpColor(sunsetTreeMid, nightTreeMid, nt);
                colors.grass = lerpColor(sunsetGrass, nightGrass, nt);
                colors.cloud = nt < 0.5 ? sunsetCloud : nightCloud;
                colors.isNight = nt > 0.5;
                colors.sunY = 160 + nt * 200;
            } else {
                // Night to Day
                const dt = t - 2;
                colors.skyTop = lerpColor(nightTop, dayTop, dt);
                colors.skyBottom = lerpColor(nightBottom, dayBottom, dt);
                colors.sun = lerpColor(sunsetSun, daySun, dt);
                colors.treeFar = lerpColor(nightTreeFar, dayTreeFar, dt);
                colors.treeMid = lerpColor(nightTreeMid, dayTreeMid, dt);
                colors.grass = lerpColor(nightGrass, dayGrass, dt);
                colors.cloud = dt < 0.5 ? nightCloud : dayCloud;
                colors.isNight = dt < 0.3;
                colors.sunY = 360 - dt * 300;
            }

            return colors;
        }

        function drawSun(x, y, colors) {
            if (y > GROUND_Y + 50) return; // Sun below horizon

            // Sun glow (outer)
            const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, 80);
            glowGradient.addColorStop(0, 'rgba(255, 200, 100, 0.4)');
            glowGradient.addColorStop(0.5, 'rgba(255, 150, 50, 0.2)');
            glowGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(x, y, 80, 0, Math.PI * 2);
            ctx.fill();

            // Sun rays
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Date.now() / 5000);
            for (let i = 0; i < 12; i++) {
                ctx.rotate(Math.PI / 6);
                ctx.fillStyle = 'rgba(255, 220, 100, 0.3)';
                ctx.beginPath();
                ctx.moveTo(0, -35);
                ctx.lineTo(-8, -60);
                ctx.lineTo(0, -55);
                ctx.lineTo(8, -60);
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();

            // Sun outer ring
            ctx.fillStyle = colors.sun;
            ctx.beginPath();
            ctx.arc(x, y, 35, 0, Math.PI * 2);
            ctx.fill();

            // Sun middle
            const sunGradient = ctx.createRadialGradient(x - 10, y - 10, 0, x, y, 35);
            sunGradient.addColorStop(0, '#FFFDE7');
            sunGradient.addColorStop(0.5, '#FFF59D');
            sunGradient.addColorStop(1, colors.sun);
            ctx.fillStyle = sunGradient;
            ctx.beginPath();
            ctx.arc(x, y, 30, 0, Math.PI * 2);
            ctx.fill();

            // Sun highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(x - 10, y - 10, 12, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawMoon(x, y) {
            // Moon glow
            const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, 60);
            glowGradient.addColorStop(0, 'rgba(200, 200, 255, 0.3)');
            glowGradient.addColorStop(1, 'rgba(100, 100, 200, 0)');
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(x, y, 60, 0, Math.PI * 2);
            ctx.fill();

            // Moon body
            ctx.fillStyle = '#F5F5F5';
            ctx.beginPath();
            ctx.arc(x, y, 30, 0, Math.PI * 2);
            ctx.fill();

            // Moon craters
            ctx.fillStyle = '#E0E0E0';
            ctx.beginPath();
            ctx.arc(x - 10, y - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 8, y + 10, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 5, y - 12, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#D0D0D0';
            ctx.beginPath();
            ctx.arc(x - 5, y + 8, 6, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawStars() {
            const starPositions = [
                [50, 30], [150, 60], [250, 25], [350, 70], [450, 40],
                [550, 55], [650, 20], [750, 65], [100, 90], [300, 100],
                [500, 85], [700, 95], [200, 45], [400, 35], [600, 50]
            ];
            const twinkle = Math.sin(Date.now() / 500) * 0.3 + 0.7;

            ctx.fillStyle = `rgba(255, 255, 255, ${twinkle})`;
            starPositions.forEach(([sx, sy]) => {
                ctx.beginPath();
                ctx.arc(sx, sy, 1.5, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawBackground() {
            const colors = getTimeColors();

            // Sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
            skyGradient.addColorStop(0, colors.skyTop);
            skyGradient.addColorStop(1, colors.skyBottom);
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, GROUND_Y);

            // Stars (only at night)
            if (colors.isNight) {
                drawStars();
            }

            // Sun or Moon
            if (colors.isNight) {
                drawMoon(650, 60);
            } else {
                drawSun(650, colors.sunY, colors);
            }

            // Clouds
            ctx.fillStyle = colors.cloud;
            drawCloud(100 - cloudOffset % 900, 50);
            drawCloud(400 - cloudOffset % 900, 80);
            drawCloud(700 - cloudOffset % 900, 40);
            drawCloud(1000 - cloudOffset % 900, 70);

            // Far background hill/ground for trees
            ctx.fillStyle = colors.treeFar;
            ctx.beginPath();
            ctx.moveTo(0, GROUND_Y - 40);
            ctx.lineTo(CANVAS_WIDTH, GROUND_Y - 40);
            ctx.lineTo(CANVAS_WIDTH, GROUND_Y);
            ctx.lineTo(0, GROUND_Y);
            ctx.closePath();
            ctx.fill();

            // Background trees (far) - on the far ground
            for (let i = 0; i < 10; i++) {
                const x = (i * 120 - (bgOffset * 0.3) % 120) - 60;
                drawTree(x, GROUND_Y - 40, 0.6, colors.treeFar);
            }

            // Middle ground layer
            ctx.fillStyle = colors.treeMid;
            ctx.beginPath();
            ctx.moveTo(0, GROUND_Y - 20);
            ctx.lineTo(CANVAS_WIDTH, GROUND_Y - 20);
            ctx.lineTo(CANVAS_WIDTH, GROUND_Y);
            ctx.lineTo(0, GROUND_Y);
            ctx.closePath();
            ctx.fill();

            // Middle trees - on middle ground
            for (let i = 0; i < 8; i++) {
                const x = (i * 150 - (bgOffset * 0.5) % 150) - 75;
                drawTree(x, GROUND_Y - 20, 0.8, colors.treeMid);
            }

            // Foreground grass layer
            ctx.fillStyle = colors.grass;
            ctx.beginPath();
            ctx.moveTo(0, GROUND_Y - 5);
            ctx.lineTo(CANVAS_WIDTH, GROUND_Y - 5);
            ctx.lineTo(CANVAS_WIDTH, GROUND_Y);
            ctx.lineTo(0, GROUND_Y);
            ctx.closePath();
            ctx.fill();

            // Foreground bushes
            ctx.fillStyle = colors.treeMid;
            for (let i = 0; i < 12; i++) {
                const x = (i * 100 - (bgOffset * 0.7) % 100) - 50;
                drawBush(x, GROUND_Y - 15);
            }

            // Main ground (path/dirt)
            const groundGradient = ctx.createLinearGradient(0, GROUND_Y, 0, CANVAS_HEIGHT);
            groundGradient.addColorStop(0, '#8B4513');
            groundGradient.addColorStop(0.3, '#654321');
            groundGradient.addColorStop(1, '#3D2314');
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, CANVAS_HEIGHT - GROUND_Y);

            // Grass on top of ground
            ctx.strokeStyle = colors.grass;
            ctx.lineWidth = 2;
            for (let i = 0; i < 100; i++) {
                const x = (i * 12 - bgOffset % 12);
                ctx.beginPath();
                ctx.moveTo(x, GROUND_Y);
                ctx.lineTo(x + 3, GROUND_Y - 8 - Math.random() * 5);
                ctx.stroke();
            }
        }

        function drawCloud(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, 25, 0, Math.PI * 2);
            ctx.arc(x + 25, y - 10, 30, 0, Math.PI * 2);
            ctx.arc(x + 50, y, 25, 0, Math.PI * 2);
            ctx.arc(x + 25, y + 5, 20, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTree(x, y, scale, color) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);

            // Trunk
            ctx.fillStyle = '#4A3728';
            ctx.fillRect(-8, 0, 16, 60);

            // Foliage
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0, -80);
            ctx.lineTo(-40, 0);
            ctx.lineTo(40, 0);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(0, -50);
            ctx.lineTo(-35, 20);
            ctx.lineTo(35, 20);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        function drawBush(x, y) {
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, Math.PI * 2);
            ctx.arc(x + 15, y - 5, 18, 0, Math.PI * 2);
            ctx.arc(x + 30, y, 20, 0, Math.PI * 2);
            ctx.fill();
        }

        // ============================================
        // PATTERN CHUNK 9: Score System
        // ============================================
        function updateScore(deltaTime) {
            score += deltaTime * 0.01; // Time-based score
        }

        function updateUI() {
            document.getElementById('scoreDisplay').textContent = `Score: ${Math.floor(score)}`;
            document.getElementById('highScoreDisplay').textContent = `High Score: ${highScore}`;
        }

        // ============================================
        // PATTERN CHUNK 2: Game Loop
        // ============================================
        function gameLoop(timestamp) {
            if (lastTime === 0) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            if (currentState === GameState.PLAYING) {
                const elapsedTime = timestamp - gameStartTime;

                // Update difficulty
                DifficultyManager.update(elapsedTime);

                // Update background offset
                bgOffset += DifficultyManager.currentSpeed;
                cloudOffset += DifficultyManager.currentSpeed * 0.2;

                // Update time of day (full cycle every 90 seconds)
                timeOfDay = (elapsedTime / 30000) % 3;

                // Update game objects
                monkey.update(deltaTime);
                updateSnakes(deltaTime, elapsedTime);
                updateBananas(deltaTime, elapsedTime);
                updateRivers(deltaTime, elapsedTime);
                updateScore(deltaTime);

                // Check collisions
                const collisionResult = checkCollisions();
                if (collisionResult === 'death' && !monkey.isDead) {
                    monkey.isDead = true;
                    monkey.velocityY = -10;
                    setTimeout(() => {
                        endGame();
                    }, 1000);
                }

                // Draw everything
                drawBackground();

                // Draw rivers (before other objects)
                rivers.forEach(drawRiver);

                // Draw platforms
                platforms.forEach(drawPlatform);

                // Draw snakes
                snakes.forEach(drawSnake);

                // Draw bananas
                bananas.forEach(drawBanana);

                // Draw monkey
                monkey.draw();

                // Update UI
                updateUI();
            }

            requestAnimationFrame(gameLoop);
        }

        // ============================================
        // Game Control Functions
        // ============================================
        function startGame() {
            currentState = GameState.PLAYING;
            score = 0;
            snakes = [];
            bananas = [];
            rivers = [];
            platforms = [];
            lastSnakeSpawn = 0;
            lastBananaSpawn = 0;
            lastRiverSpawn = 0;
            nextSnakeDelay = 1500;
            timeOfDay = 0;
            gameStartTime = performance.now();
            isNewRecord = false;

            monkey.reset();
            DifficultyManager.reset();
            AudioManager.init();

            document.getElementById('overlay').classList.add('hidden');
        }

        function endGame() {
            currentState = GameState.GAME_OVER;
            isNewRecord = HighScoreManager.set(Math.floor(score));
            if (isNewRecord) {
                highScore = Math.floor(score);
            }
            showGameOver();
        }

        function showGameOver() {
            const overlay = document.getElementById('overlay');
            overlay.innerHTML = `
                <h2>GAME OVER</h2>
                <p class="score-display">Score: ${Math.floor(score)}</p>
                <p class="score-display high-score">High Score: ${highScore}</p>
                ${isNewRecord ? '<p class="new-record">üéâ NEW RECORD! üéâ</p>' : ''}
                <p>Level Reached: ${DifficultyManager.level}</p>
                <button id="restartBtn">PLAY AGAIN</button>
            `;
            overlay.classList.remove('hidden');

            document.getElementById('restartBtn').addEventListener('click', startGame);
        }

        function showMenu() {
            const overlay = document.getElementById('overlay');
            document.getElementById('menuHighScore').textContent = `High Score: ${highScore}`;
            overlay.classList.remove('hidden');
        }

        // ============================================
        // PATTERN CHUNK 4: Jump Mechanics (Input)
        // ============================================
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (currentState === GameState.PLAYING) {
                    monkey.jump();
                } else if (currentState === GameState.MENU) {
                    startGame();
                } else if (currentState === GameState.GAME_OVER) {
                    startGame();
                }
            }
        });

        // Start button
        document.getElementById('startBtn').addEventListener('click', startGame);

        // Initialize
        highScore = HighScoreManager.get();
        document.getElementById('menuHighScore').textContent = `High Score: ${highScore}`;
        document.getElementById('highScoreDisplay').textContent = `High Score: ${highScore}`;

        // Draw initial background
        drawBackground();

        // Start game loop
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
