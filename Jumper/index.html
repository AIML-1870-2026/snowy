<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jumper - Jungle Runner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(to bottom, #1a3a1a, #0d1f0d);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
            border: 4px solid #4a2c0a;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #gameCanvas {
            display: block;
            background: #87CEEB;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.7);
            color: white;
            text-align: center;
        }
        #overlay.hidden {
            display: none;
        }
        #overlay h1 {
            font-size: 48px;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }
        #overlay h2 {
            font-size: 32px;
            color: #FF6B6B;
            margin-bottom: 10px;
        }
        #overlay p {
            font-size: 20px;
            margin: 10px 0;
        }
        #overlay .score-display {
            font-size: 24px;
            color: #90EE90;
            margin: 5px 0;
        }
        #overlay .high-score {
            color: #FFD700;
        }
        #overlay .new-record {
            color: #FF69B4;
            font-size: 28px;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }
        #overlay .instructions {
            font-size: 16px;
            color: #ccc;
            margin-top: 20px;
        }
        #startBtn, #restartBtn {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(to bottom, #4CAF50, #2E7D32);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        #startBtn:hover, #restartBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.4);
        }
        #startBtn:active, #restartBtn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        <div id="ui">
            <span id="scoreDisplay">Score: 0</span>
            <span id="highScoreDisplay">High Score: 0</span>
        </div>
        <div id="overlay">
            <h1>üêµ JUMPER üêµ</h1>
            <p>Help the monkey escape through the jungle!</p>
            <p class="instructions">Press SPACE to jump over snakes</p>
            <p class="instructions">Collect bananas for bonus points!</p>
            <p class="score-display high-score" id="menuHighScore">High Score: 0</p>
            <button id="startBtn">START GAME</button>
        </div>
    </div>

    <script>
        // ============================================
        // PATTERN CHUNK 1: Game Canvas
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;
        const GROUND_Y = CANVAS_HEIGHT - 60;

        // ============================================
        // PATTERN CHUNK 11: Audio Manager
        // ============================================
        const AudioManager = {
            jumpSound: null,
            collectSound: null,
            initialized: false,

            init() {
                if (this.initialized) return;

                // Create jump sound using oscillator
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.initialized = true;
            },

            playJump() {
                if (!this.initialized) this.init();

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(600, this.audioContext.currentTime + 0.1);

                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.2);
            },

            playCollect() {
                if (!this.initialized) this.init();

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 0.1);

                gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.15);
            }
        };

        // ============================================
        // PATTERN CHUNK 13: High Score Manager
        // ============================================
        const HighScoreManager = {
            key: 'jumper_high_score',

            get() {
                const score = localStorage.getItem(this.key);
                return score ? parseInt(score, 10) : 0;
            },

            set(score) {
                const current = this.get();
                if (score > current) {
                    localStorage.setItem(this.key, score.toString());
                    return true; // New record!
                }
                return false;
            }
        };

        // ============================================
        // PATTERN CHUNK 12: Difficulty Manager
        // ============================================
        const DifficultyManager = {
            baseSpeed: 5,
            baseSpawnRate: 1500,
            currentSpeed: 5,
            currentSpawnRate: 1500,
            level: 1,
            lastLevelUp: 0,
            levelUpInterval: 10000, // 10 seconds

            reset() {
                this.currentSpeed = this.baseSpeed;
                this.currentSpawnRate = this.baseSpawnRate;
                this.level = 1;
                this.lastLevelUp = 0;
            },

            update(elapsedTime) {
                if (elapsedTime - this.lastLevelUp >= this.levelUpInterval) {
                    this.level++;
                    this.currentSpeed = this.baseSpeed + (this.level - 1) * 0.5;
                    this.currentSpawnRate = Math.max(500, this.baseSpawnRate - (this.level - 1) * 100);
                    this.lastLevelUp = elapsedTime;
                    return true; // Level up occurred
                }
                return false;
            }
        };

        // ============================================
        // PATTERN CHUNK 10: Game State Manager
        // ============================================
        const GameState = {
            MENU: 'menu',
            PLAYING: 'playing',
            GAME_OVER: 'gameOver'
        };

        let currentState = GameState.MENU;
        let score = 0;
        let highScore = HighScoreManager.get();
        let isNewRecord = false;
        let gameStartTime = 0;
        let lastTime = 0;

        // ============================================
        // PATTERN CHUNK 3: Player Character (Monkey)
        // ============================================
        const monkey = {
            x: 100,
            y: GROUND_Y,
            width: 50,
            height: 60,
            velocityY: 0,
            isJumping: false,
            isDead: false,
            deathRotation: 0,
            runFrame: 0,
            frameTimer: 0,

            reset() {
                this.y = GROUND_Y - this.height;
                this.velocityY = 0;
                this.isJumping = false;
                this.isDead = false;
                this.deathRotation = 0;
                this.runFrame = 0;
            },

            jump() {
                if (!this.isJumping && !this.isDead) {
                    this.velocityY = -15;
                    this.isJumping = true;
                    AudioManager.playJump();
                }
            },

            update(deltaTime) {
                if (this.isDead) {
                    // Death animation
                    if (this.deathRotation < Math.PI / 2) {
                        this.deathRotation += 0.1;
                    }
                    if (this.y < GROUND_Y - 20) {
                        this.velocityY += 0.8;
                        this.y += this.velocityY;
                    }
                    return;
                }

                // Gravity
                this.velocityY += 0.8;
                this.y += this.velocityY;

                // Ground collision
                if (this.y >= GROUND_Y - this.height) {
                    this.y = GROUND_Y - this.height;
                    this.velocityY = 0;
                    this.isJumping = false;
                }

                // Animation frame
                this.frameTimer += deltaTime;
                if (this.frameTimer > 100) {
                    this.runFrame = (this.runFrame + 1) % 4;
                    this.frameTimer = 0;
                }
            },

            draw() {
                ctx.save();

                if (this.isDead) {
                    ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                    ctx.rotate(this.deathRotation);
                    ctx.translate(-this.width / 2, -this.height / 2);
                } else {
                    ctx.translate(this.x, this.y);
                }

                // Body (brown)
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.ellipse(this.width / 2, this.height / 2 + 5, 20, 25, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = '#A0522D';
                ctx.beginPath();
                ctx.arc(this.width / 2, 15, 18, 0, Math.PI * 2);
                ctx.fill();

                // Face (lighter)
                ctx.fillStyle = '#DEB887';
                ctx.beginPath();
                ctx.ellipse(this.width / 2, 18, 12, 10, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                ctx.fillStyle = this.isDead ? 'red' : 'black';
                ctx.beginPath();
                ctx.arc(this.width / 2 - 5, 14, 3, 0, Math.PI * 2);
                ctx.arc(this.width / 2 + 5, 14, 3, 0, Math.PI * 2);
                ctx.fill();

                // Ears
                ctx.fillStyle = '#DEB887';
                ctx.beginPath();
                ctx.arc(this.width / 2 - 16, 12, 6, 0, Math.PI * 2);
                ctx.arc(this.width / 2 + 16, 12, 6, 0, Math.PI * 2);
                ctx.fill();

                // Mouth
                ctx.strokeStyle = '#5D3A1A';
                ctx.lineWidth = 2;
                ctx.beginPath();
                if (this.isDead) {
                    ctx.arc(this.width / 2, 24, 4, 0, Math.PI, true);
                } else {
                    ctx.arc(this.width / 2, 22, 4, 0, Math.PI);
                }
                ctx.stroke();

                // Legs (animated)
                ctx.fillStyle = '#8B4513';
                const legOffset = this.isJumping ? 0 : Math.sin(this.runFrame * Math.PI / 2) * 5;

                // Left leg
                ctx.fillRect(this.width / 2 - 12, this.height - 15 + legOffset, 8, 15);
                // Right leg
                ctx.fillRect(this.width / 2 + 4, this.height - 15 - legOffset, 8, 15);

                // Arms
                const armY = this.isJumping ? -5 : 0;
                ctx.fillRect(this.width / 2 - 25, 30 + armY, 10, 20);
                ctx.fillRect(this.width / 2 + 15, 30 + armY, 10, 20);

                // Tail
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(this.width / 2 - 15, this.height / 2 + 10);
                ctx.quadraticCurveTo(-10, this.height / 2, -5, this.height / 2 - 15);
                ctx.stroke();

                ctx.restore();
            },

            getBounds() {
                return {
                    x: this.x + 10,
                    y: this.y + 10,
                    width: this.width - 20,
                    height: this.height - 10
                };
            }
        };

        // ============================================
        // PATTERN CHUNK 6: Obstacle Spawner (Snakes)
        // ============================================
        let snakes = [];
        let lastSnakeSpawn = 0;

        function spawnSnake() {
            snakes.push({
                x: CANVAS_WIDTH + 50,
                y: GROUND_Y - 25,
                width: 60,
                height: 25,
                waveOffset: Math.random() * Math.PI * 2
            });
        }

        function updateSnakes(deltaTime, currentTime) {
            // Spawn new snakes
            if (currentTime - lastSnakeSpawn > DifficultyManager.currentSpawnRate) {
                spawnSnake();
                lastSnakeSpawn = currentTime;
            }

            // Update positions
            snakes.forEach(snake => {
                snake.x -= DifficultyManager.currentSpeed;
            });

            // Remove off-screen snakes
            snakes = snakes.filter(snake => snake.x > -100);
        }

        function drawSnake(snake) {
            ctx.save();
            ctx.translate(snake.x, snake.y);

            // Body segments (wavy)
            ctx.fillStyle = '#228B22';
            for (let i = 0; i < 5; i++) {
                const segX = i * 12;
                const segY = Math.sin((Date.now() / 200) + snake.waveOffset + i * 0.5) * 3;
                ctx.beginPath();
                ctx.ellipse(segX, segY + 12, 8, 6, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Head
            ctx.fillStyle = '#32CD32';
            ctx.beginPath();
            ctx.ellipse(55, 10, 10, 8, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            ctx.arc(58, 6, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(59, 6, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Tongue
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(64, 10);
            ctx.lineTo(70, 8);
            ctx.moveTo(67, 9);
            ctx.lineTo(70, 12);
            ctx.stroke();

            // Pattern on body
            ctx.fillStyle = '#006400';
            for (let i = 0; i < 4; i++) {
                const segX = i * 12 + 6;
                const segY = Math.sin((Date.now() / 200) + snake.waveOffset + i * 0.5) * 3;
                ctx.beginPath();
                ctx.arc(segX, segY + 12, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        // ============================================
        // PATTERN CHUNK 7: Collectible Spawner (Bananas)
        // ============================================
        let bananas = [];
        let lastBananaSpawn = 0;
        const BANANA_SPAWN_RATE = 2000;

        function spawnBanana() {
            const isAirBanana = Math.random() > 0.5;
            bananas.push({
                x: CANVAS_WIDTH + 30,
                y: isAirBanana ? GROUND_Y - 120 - Math.random() * 50 : GROUND_Y - 40,
                width: 30,
                height: 30,
                rotation: Math.random() * 0.5 - 0.25,
                isAir: isAirBanana
            });
        }

        function updateBananas(deltaTime, currentTime) {
            // Spawn new bananas
            if (currentTime - lastBananaSpawn > BANANA_SPAWN_RATE) {
                if (Math.random() > 0.3) { // 70% chance to spawn
                    spawnBanana();
                }
                lastBananaSpawn = currentTime;
            }

            // Update positions
            bananas.forEach(banana => {
                banana.x -= DifficultyManager.currentSpeed;
            });

            // Remove off-screen bananas
            bananas = bananas.filter(banana => banana.x > -50);
        }

        function drawBanana(banana) {
            ctx.save();
            ctx.translate(banana.x + banana.width / 2, banana.y + banana.height / 2);
            ctx.rotate(banana.rotation + Math.sin(Date.now() / 300) * 0.1);

            // Banana shape
            ctx.fillStyle = '#FFE135';
            ctx.beginPath();
            ctx.moveTo(-12, 8);
            ctx.quadraticCurveTo(-15, 0, -10, -10);
            ctx.quadraticCurveTo(0, -15, 10, -10);
            ctx.quadraticCurveTo(15, 0, 12, 8);
            ctx.quadraticCurveTo(0, 12, -12, 8);
            ctx.fill();

            // Banana tips
            ctx.fillStyle = '#8B7355';
            ctx.beginPath();
            ctx.arc(-11, -8, 3, 0, Math.PI * 2);
            ctx.arc(11, -8, 3, 0, Math.PI * 2);
            ctx.fill();

            // Highlight
            ctx.strokeStyle = '#FFF8DC';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-5, -5);
            ctx.quadraticCurveTo(0, -8, 5, -5);
            ctx.stroke();

            ctx.restore();
        }

        // ============================================
        // PATTERN CHUNK 8: Collision Detection
        // ============================================
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function checkCollisions() {
            const monkeyBounds = monkey.getBounds();

            // Check snake collisions
            for (const snake of snakes) {
                const snakeBounds = {
                    x: snake.x + 10,
                    y: snake.y,
                    width: snake.width - 10,
                    height: snake.height
                };
                if (checkCollision(monkeyBounds, snakeBounds)) {
                    return 'death';
                }
            }

            // Check banana collisions
            for (let i = bananas.length - 1; i >= 0; i--) {
                const banana = bananas[i];
                const bananaBounds = {
                    x: banana.x,
                    y: banana.y,
                    width: banana.width,
                    height: banana.height
                };
                if (checkCollision(monkeyBounds, bananaBounds)) {
                    bananas.splice(i, 1);
                    score += 50;
                    AudioManager.playCollect();
                }
            }

            return null;
        }

        // ============================================
        // PATTERN CHUNK 5: Ground & Scrolling Background
        // ============================================
        let bgOffset = 0;
        let cloudOffset = 0;

        function drawBackground() {
            // Sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
            skyGradient.addColorStop(0, '#87CEEB');
            skyGradient.addColorStop(1, '#E0F6FF');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, GROUND_Y);

            // Sun
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(650, 60, 40, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFF8DC';
            ctx.beginPath();
            ctx.arc(650, 60, 30, 0, Math.PI * 2);
            ctx.fill();

            // Clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            drawCloud(100 - cloudOffset % 900, 50);
            drawCloud(400 - cloudOffset % 900, 80);
            drawCloud(700 - cloudOffset % 900, 40);
            drawCloud(1000 - cloudOffset % 900, 70);

            // Background trees (far)
            ctx.fillStyle = '#1B4D1B';
            for (let i = 0; i < 10; i++) {
                const x = (i * 120 - (bgOffset * 0.3) % 120) - 60;
                drawTree(x, GROUND_Y - 100, 0.6, '#1B4D1B');
            }

            // Middle trees
            ctx.fillStyle = '#228B22';
            for (let i = 0; i < 8; i++) {
                const x = (i * 150 - (bgOffset * 0.5) % 150) - 75;
                drawTree(x, GROUND_Y - 80, 0.8, '#228B22');
            }

            // Foreground bushes
            ctx.fillStyle = '#32CD32';
            for (let i = 0; i < 12; i++) {
                const x = (i * 100 - (bgOffset * 0.7) % 100) - 50;
                drawBush(x, GROUND_Y - 20);
            }

            // Ground
            const groundGradient = ctx.createLinearGradient(0, GROUND_Y, 0, CANVAS_HEIGHT);
            groundGradient.addColorStop(0, '#8B4513');
            groundGradient.addColorStop(0.3, '#654321');
            groundGradient.addColorStop(1, '#3D2314');
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, CANVAS_HEIGHT - GROUND_Y);

            // Grass on top of ground
            ctx.strokeStyle = '#228B22';
            ctx.lineWidth = 2;
            for (let i = 0; i < 100; i++) {
                const x = (i * 12 - bgOffset % 12);
                ctx.beginPath();
                ctx.moveTo(x, GROUND_Y);
                ctx.lineTo(x + 3, GROUND_Y - 8 - Math.random() * 5);
                ctx.stroke();
            }
        }

        function drawCloud(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, 25, 0, Math.PI * 2);
            ctx.arc(x + 25, y - 10, 30, 0, Math.PI * 2);
            ctx.arc(x + 50, y, 25, 0, Math.PI * 2);
            ctx.arc(x + 25, y + 5, 20, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTree(x, y, scale, color) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);

            // Trunk
            ctx.fillStyle = '#4A3728';
            ctx.fillRect(-8, 0, 16, 60);

            // Foliage
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0, -80);
            ctx.lineTo(-40, 0);
            ctx.lineTo(40, 0);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(0, -50);
            ctx.lineTo(-35, 20);
            ctx.lineTo(35, 20);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        function drawBush(x, y) {
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, Math.PI * 2);
            ctx.arc(x + 15, y - 5, 18, 0, Math.PI * 2);
            ctx.arc(x + 30, y, 20, 0, Math.PI * 2);
            ctx.fill();
        }

        // ============================================
        // PATTERN CHUNK 9: Score System
        // ============================================
        function updateScore(deltaTime) {
            score += deltaTime * 0.01; // Time-based score
        }

        function updateUI() {
            document.getElementById('scoreDisplay').textContent = `Score: ${Math.floor(score)}`;
            document.getElementById('highScoreDisplay').textContent = `High Score: ${highScore}`;
        }

        // ============================================
        // PATTERN CHUNK 2: Game Loop
        // ============================================
        function gameLoop(timestamp) {
            if (lastTime === 0) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            if (currentState === GameState.PLAYING) {
                const elapsedTime = timestamp - gameStartTime;

                // Update difficulty
                DifficultyManager.update(elapsedTime);

                // Update background offset
                bgOffset += DifficultyManager.currentSpeed;
                cloudOffset += DifficultyManager.currentSpeed * 0.2;

                // Update game objects
                monkey.update(deltaTime);
                updateSnakes(deltaTime, elapsedTime);
                updateBananas(deltaTime, elapsedTime);
                updateScore(deltaTime);

                // Check collisions
                const collisionResult = checkCollisions();
                if (collisionResult === 'death' && !monkey.isDead) {
                    monkey.isDead = true;
                    monkey.velocityY = -10;
                    setTimeout(() => {
                        endGame();
                    }, 1000);
                }

                // Draw everything
                drawBackground();

                // Draw snakes
                snakes.forEach(drawSnake);

                // Draw bananas
                bananas.forEach(drawBanana);

                // Draw monkey
                monkey.draw();

                // Update UI
                updateUI();
            }

            requestAnimationFrame(gameLoop);
        }

        // ============================================
        // Game Control Functions
        // ============================================
        function startGame() {
            currentState = GameState.PLAYING;
            score = 0;
            snakes = [];
            bananas = [];
            lastSnakeSpawn = 0;
            lastBananaSpawn = 0;
            gameStartTime = performance.now();
            isNewRecord = false;

            monkey.reset();
            DifficultyManager.reset();
            AudioManager.init();

            document.getElementById('overlay').classList.add('hidden');
        }

        function endGame() {
            currentState = GameState.GAME_OVER;
            isNewRecord = HighScoreManager.set(Math.floor(score));
            if (isNewRecord) {
                highScore = Math.floor(score);
            }
            showGameOver();
        }

        function showGameOver() {
            const overlay = document.getElementById('overlay');
            overlay.innerHTML = `
                <h2>GAME OVER</h2>
                <p class="score-display">Score: ${Math.floor(score)}</p>
                <p class="score-display high-score">High Score: ${highScore}</p>
                ${isNewRecord ? '<p class="new-record">üéâ NEW RECORD! üéâ</p>' : ''}
                <p>Level Reached: ${DifficultyManager.level}</p>
                <button id="restartBtn">PLAY AGAIN</button>
            `;
            overlay.classList.remove('hidden');

            document.getElementById('restartBtn').addEventListener('click', startGame);
        }

        function showMenu() {
            const overlay = document.getElementById('overlay');
            document.getElementById('menuHighScore').textContent = `High Score: ${highScore}`;
            overlay.classList.remove('hidden');
        }

        // ============================================
        // PATTERN CHUNK 4: Jump Mechanics (Input)
        // ============================================
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (currentState === GameState.PLAYING) {
                    monkey.jump();
                } else if (currentState === GameState.MENU) {
                    startGame();
                } else if (currentState === GameState.GAME_OVER) {
                    startGame();
                }
            }
        });

        // Start button
        document.getElementById('startBtn').addEventListener('click', startGame);

        // Initialize
        highScore = HighScoreManager.get();
        document.getElementById('menuHighScore').textContent = `High Score: ${highScore}`;
        document.getElementById('highScoreDisplay').textContent = `High Score: ${highScore}`;

        // Draw initial background
        drawBackground();

        // Start game loop
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
