<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jumper - Jungle Runner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(to bottom, #1a3a1a, #0d1f0d);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
            border: 4px solid #4a2c0a;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #gameCanvas {
            display: block;
            background: #87CEEB;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.7);
            color: white;
            text-align: center;
        }
        #overlay.hidden {
            display: none;
        }
        #overlay h1 {
            font-size: 48px;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }
        #overlay h2 {
            font-size: 32px;
            color: #FF6B6B;
            margin-bottom: 10px;
        }
        #overlay p {
            font-size: 20px;
            margin: 10px 0;
        }
        #overlay .score-display {
            font-size: 24px;
            color: #90EE90;
            margin: 5px 0;
        }
        #overlay .high-score {
            color: #FFD700;
        }
        #overlay .new-record {
            color: #FF69B4;
            font-size: 28px;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }
        #overlay .instructions {
            font-size: 16px;
            color: #ccc;
            margin-top: 20px;
        }
        #startBtn, #restartBtn {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(to bottom, #4CAF50, #2E7D32);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        #startBtn:hover, #restartBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.4);
        }
        #startBtn:active, #restartBtn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        <div id="ui">
            <span id="scoreDisplay">Score: 0</span>
            <span id="highScoreDisplay">High Score: 0</span>
        </div>
        <div id="overlay">
            <h1>üêµ JUMPER üêµ</h1>
            <p>Help the monkey escape through the jungle!</p>
            <p class="instructions">Press SPACE to jump over snakes</p>
            <p class="instructions">Collect bananas for bonus points!</p>
            <p class="score-display high-score" id="menuHighScore">High Score: 0</p>
            <button id="startBtn">START GAME</button>
        </div>
    </div>

    <script>
        // ============================================
        // PATTERN CHUNK 1: Game Canvas
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;
        const GROUND_Y = CANVAS_HEIGHT - 60;

        // ============================================
        // PATTERN CHUNK 11: Audio Manager
        // ============================================
        const AudioManager = {
            jumpSound: null,
            collectSound: null,
            initialized: false,

            init() {
                if (this.initialized) return;

                // Create jump sound using oscillator
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.initialized = true;
            },

            playJump() {
                if (!this.initialized) this.init();

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(600, this.audioContext.currentTime + 0.1);

                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.2);
            },

            playCollect() {
                if (!this.initialized) this.init();

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 0.1);

                gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.15);
            }
        };

        // ============================================
        // PATTERN CHUNK 13: High Score Manager
        // ============================================
        const HighScoreManager = {
            key: 'jumper_high_score',

            get() {
                const score = localStorage.getItem(this.key);
                return score ? parseInt(score, 10) : 0;
            },

            set(score) {
                const current = this.get();
                if (score > current) {
                    localStorage.setItem(this.key, score.toString());
                    return true; // New record!
                }
                return false;
            }
        };

        // ============================================
        // PATTERN CHUNK 12: Difficulty Manager
        // ============================================
        const DifficultyManager = {
            baseSpeed: 5,
            baseSpawnRate: 1500,
            currentSpeed: 5,
            currentSpawnRate: 1500,
            level: 1,
            lastLevelUp: 0,
            levelUpInterval: 10000, // 10 seconds

            reset() {
                this.currentSpeed = this.baseSpeed;
                this.currentSpawnRate = this.baseSpawnRate;
                this.level = 1;
                this.lastLevelUp = 0;
            },

            update(elapsedTime) {
                if (elapsedTime - this.lastLevelUp >= this.levelUpInterval) {
                    this.level++;
                    this.currentSpeed = this.baseSpeed + (this.level - 1) * 0.5;
                    this.currentSpawnRate = Math.max(500, this.baseSpawnRate - (this.level - 1) * 100);
                    this.lastLevelUp = elapsedTime;
                    return true; // Level up occurred
                }
                return false;
            }
        };

        // ============================================
        // PATTERN CHUNK 10: Game State Manager
        // ============================================
        const GameState = {
            MENU: 'menu',
            PLAYING: 'playing',
            GAME_OVER: 'gameOver'
        };

        let currentState = GameState.MENU;
        let score = 0;
        let highScore = HighScoreManager.get();
        let isNewRecord = false;
        let gameStartTime = 0;
        let lastTime = 0;

        // ============================================
        // PATTERN CHUNK 3: Player Character (Monkey)
        // ============================================
        const monkey = {
            x: 100,
            y: GROUND_Y,
            width: 50,
            height: 60,
            velocityY: 0,
            isJumping: false,
            isDead: false,
            deathRotation: 0,
            runFrame: 0,
            frameTimer: 0,

            reset() {
                this.y = GROUND_Y - this.height;
                this.velocityY = 0;
                this.isJumping = false;
                this.isDead = false;
                this.deathRotation = 0;
                this.runFrame = 0;
            },

            jump() {
                if (!this.isJumping && !this.isDead) {
                    this.velocityY = -15;
                    this.isJumping = true;
                    AudioManager.playJump();
                }
            },

            update(deltaTime) {
                if (this.isDead) {
                    // Death animation
                    if (this.deathRotation < Math.PI / 2) {
                        this.deathRotation += 0.1;
                    }
                    if (this.y < GROUND_Y - 20) {
                        this.velocityY += 0.8;
                        this.y += this.velocityY;
                    }
                    return;
                }

                // Gravity
                this.velocityY += 0.8;
                this.y += this.velocityY;

                // Ground collision
                if (this.y >= GROUND_Y - this.height) {
                    this.y = GROUND_Y - this.height;
                    this.velocityY = 0;
                    this.isJumping = false;
                }

                // Animation frame
                this.frameTimer += deltaTime;
                if (this.frameTimer > 100) {
                    this.runFrame = (this.runFrame + 1) % 4;
                    this.frameTimer = 0;
                }
            },

            draw() {
                ctx.save();

                if (this.isDead) {
                    ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                    ctx.rotate(this.deathRotation);
                    ctx.translate(-this.width / 2, -this.height / 2);
                } else {
                    ctx.translate(this.x, this.y);
                }

                const legOffset = this.isJumping ? 0 : Math.sin(this.runFrame * Math.PI / 2) * 5;
                const armSwing = this.isJumping ? -10 : Math.sin(this.runFrame * Math.PI / 2) * 8;

                // Tail (behind body)
                ctx.strokeStyle = '#5D4037';
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(8, this.height / 2 + 5);
                ctx.quadraticCurveTo(-15, this.height / 2 + 10, -10, this.height / 2 - 10);
                ctx.quadraticCurveTo(-5, this.height / 2 - 25, 5, this.height / 2 - 20);
                ctx.stroke();

                // Back arm (behind body)
                ctx.fillStyle = '#6D4C41';
                ctx.beginPath();
                ctx.ellipse(this.width / 2 - 18, 38 - armSwing, 6, 14, -0.3, 0, Math.PI * 2);
                ctx.fill();
                // Back hand
                ctx.fillStyle = '#BCAAA4';
                ctx.beginPath();
                ctx.arc(this.width / 2 - 20, 50 - armSwing, 5, 0, Math.PI * 2);
                ctx.fill();

                // Back leg
                ctx.fillStyle = '#6D4C41';
                ctx.beginPath();
                ctx.ellipse(this.width / 2 - 6, this.height - 8 - legOffset, 7, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                // Back foot
                ctx.fillStyle = '#4E342E';
                ctx.beginPath();
                ctx.ellipse(this.width / 2 - 6, this.height - legOffset, 8, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Body (torso) with fur texture
                ctx.fillStyle = '#795548';
                ctx.beginPath();
                ctx.ellipse(this.width / 2, this.height / 2 + 5, 16, 22, 0, 0, Math.PI * 2);
                ctx.fill();

                // Belly (lighter)
                ctx.fillStyle = '#A1887F';
                ctx.beginPath();
                ctx.ellipse(this.width / 2 + 2, this.height / 2 + 8, 10, 14, 0, 0, Math.PI * 2);
                ctx.fill();

                // Front leg
                ctx.fillStyle = '#6D4C41';
                ctx.beginPath();
                ctx.ellipse(this.width / 2 + 6, this.height - 8 + legOffset, 7, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                // Front foot
                ctx.fillStyle = '#4E342E';
                ctx.beginPath();
                ctx.ellipse(this.width / 2 + 8, this.height + legOffset, 8, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = '#6D4C41';
                ctx.beginPath();
                ctx.arc(this.width / 2, 18, 16, 0, Math.PI * 2);
                ctx.fill();

                // Fur tuft on top
                ctx.fillStyle = '#5D4037';
                ctx.beginPath();
                ctx.ellipse(this.width / 2, 4, 8, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Face (muzzle area)
                ctx.fillStyle = '#BCAAA4';
                ctx.beginPath();
                ctx.ellipse(this.width / 2, 22, 11, 9, 0, 0, Math.PI * 2);
                ctx.fill();

                // Ears
                ctx.fillStyle = '#6D4C41';
                ctx.beginPath();
                ctx.arc(this.width / 2 - 14, 14, 7, 0, Math.PI * 2);
                ctx.arc(this.width / 2 + 14, 14, 7, 0, Math.PI * 2);
                ctx.fill();
                // Inner ears
                ctx.fillStyle = '#BCAAA4';
                ctx.beginPath();
                ctx.arc(this.width / 2 - 14, 14, 4, 0, Math.PI * 2);
                ctx.arc(this.width / 2 + 14, 14, 4, 0, Math.PI * 2);
                ctx.fill();

                // Eye sockets
                ctx.fillStyle = '#4E342E';
                ctx.beginPath();
                ctx.ellipse(this.width / 2 - 6, 16, 5, 4, 0, 0, Math.PI * 2);
                ctx.ellipse(this.width / 2 + 6, 16, 5, 4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                ctx.fillStyle = this.isDead ? '#ff0000' : '#FFFFFF';
                ctx.beginPath();
                ctx.arc(this.width / 2 - 6, 16, 3.5, 0, Math.PI * 2);
                ctx.arc(this.width / 2 + 6, 16, 3.5, 0, Math.PI * 2);
                ctx.fill();

                // Pupils
                if (!this.isDead) {
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.arc(this.width / 2 - 5, 16, 2, 0, Math.PI * 2);
                    ctx.arc(this.width / 2 + 7, 16, 2, 0, Math.PI * 2);
                    ctx.fill();
                    // Eye shine
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(this.width / 2 - 4, 15, 1, 0, Math.PI * 2);
                    ctx.arc(this.width / 2 + 8, 15, 1, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // X eyes when dead
                    ctx.strokeStyle = '#1a1a1a';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.width / 2 - 8, 14);
                    ctx.lineTo(this.width / 2 - 4, 18);
                    ctx.moveTo(this.width / 2 - 4, 14);
                    ctx.lineTo(this.width / 2 - 8, 18);
                    ctx.moveTo(this.width / 2 + 4, 14);
                    ctx.lineTo(this.width / 2 + 8, 18);
                    ctx.moveTo(this.width / 2 + 8, 14);
                    ctx.lineTo(this.width / 2 + 4, 18);
                    ctx.stroke();
                }

                // Nose
                ctx.fillStyle = '#4E342E';
                ctx.beginPath();
                ctx.ellipse(this.width / 2, 23, 4, 3, 0, 0, Math.PI * 2);
                ctx.fill();
                // Nostrils
                ctx.fillStyle = '#3E2723';
                ctx.beginPath();
                ctx.arc(this.width / 2 - 1.5, 23, 1, 0, Math.PI * 2);
                ctx.arc(this.width / 2 + 1.5, 23, 1, 0, Math.PI * 2);
                ctx.fill();

                // Mouth
                ctx.strokeStyle = '#5D4037';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                if (this.isDead) {
                    ctx.arc(this.width / 2, 29, 3, 0, Math.PI, true);
                } else {
                    ctx.moveTo(this.width / 2, 26);
                    ctx.lineTo(this.width / 2, 28);
                    ctx.moveTo(this.width / 2 - 4, 29);
                    ctx.quadraticCurveTo(this.width / 2, 31, this.width / 2 + 4, 29);
                }
                ctx.stroke();

                // Front arm
                ctx.fillStyle = '#6D4C41';
                ctx.beginPath();
                ctx.ellipse(this.width / 2 + 18, 38 + armSwing, 6, 14, 0.3, 0, Math.PI * 2);
                ctx.fill();
                // Front hand
                ctx.fillStyle = '#BCAAA4';
                ctx.beginPath();
                ctx.arc(this.width / 2 + 20, 50 + armSwing, 5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            },

            getBounds() {
                return {
                    x: this.x + 10,
                    y: this.y + 10,
                    width: this.width - 20,
                    height: this.height - 10
                };
            }
        };

        // ============================================
        // PATTERN CHUNK 6: Obstacle Spawner (Snakes)
        // ============================================
        let snakes = [];
        let lastSnakeSpawn = 0;
        let nextSnakeDelay = 1500;

        function getRandomSnakeDelay() {
            const baseRate = DifficultyManager.currentSpawnRate;
            // Random variance: 50% to 180% of base rate for variety
            const variance = 0.5 + Math.random() * 1.3;
            // Occasionally create tight clusters (20% chance of quick follow-up)
            if (Math.random() < 0.2) {
                return baseRate * 0.4; // Quick follow-up snake
            }
            // Occasionally create longer gaps (15% chance)
            if (Math.random() < 0.15) {
                return baseRate * 1.8; // Longer gap
            }
            return baseRate * variance;
        }

        function spawnSnake() {
            snakes.push({
                x: CANVAS_WIDTH + 50,
                y: GROUND_Y - 25,
                width: 60,
                height: 25,
                waveOffset: Math.random() * Math.PI * 2
            });
        }

        function updateSnakes(deltaTime, currentTime) {
            // Spawn new snakes with varied timing
            if (currentTime - lastSnakeSpawn > nextSnakeDelay) {
                spawnSnake();
                lastSnakeSpawn = currentTime;
                nextSnakeDelay = getRandomSnakeDelay();
            }

            // Update positions
            snakes.forEach(snake => {
                snake.x -= DifficultyManager.currentSpeed;
            });

            // Remove off-screen snakes
            snakes = snakes.filter(snake => snake.x > -100);
        }

        function drawSnake(snake) {
            ctx.save();
            ctx.translate(snake.x, snake.y);

            // Body segments (wavy) - Red snake
            ctx.fillStyle = '#CC2222';
            for (let i = 0; i < 5; i++) {
                const segX = i * 12;
                const segY = Math.sin((Date.now() / 200) + snake.waveOffset + i * 0.5) * 3;
                ctx.beginPath();
                ctx.ellipse(segX, segY + 12, 8, 6, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Head
            ctx.fillStyle = '#E53935';
            ctx.beginPath();
            ctx.ellipse(55, 10, 10, 8, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#FFEB3B';
            ctx.beginPath();
            ctx.arc(58, 6, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(59, 6, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Tongue
            ctx.strokeStyle = '#D81B60';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(64, 10);
            ctx.lineTo(70, 8);
            ctx.moveTo(67, 9);
            ctx.lineTo(70, 12);
            ctx.stroke();

            // Pattern on body - darker red diamonds
            ctx.fillStyle = '#8B0000';
            for (let i = 0; i < 4; i++) {
                const segX = i * 12 + 6;
                const segY = Math.sin((Date.now() / 200) + snake.waveOffset + i * 0.5) * 3;
                ctx.beginPath();
                ctx.moveTo(segX, segY + 8);
                ctx.lineTo(segX + 4, segY + 12);
                ctx.lineTo(segX, segY + 16);
                ctx.lineTo(segX - 4, segY + 12);
                ctx.closePath();
                ctx.fill();
            }

            ctx.restore();
        }

        // ============================================
        // PATTERN CHUNK 7: Collectible Spawner (Bananas)
        // ============================================
        let bananas = [];
        let lastBananaSpawn = 0;
        const BANANA_SPAWN_RATE = 2000;

        function spawnBanana() {
            const isAirBanana = Math.random() > 0.5;
            bananas.push({
                x: CANVAS_WIDTH + 30,
                y: isAirBanana ? GROUND_Y - 120 - Math.random() * 50 : GROUND_Y - 40,
                width: 30,
                height: 30,
                rotation: Math.random() * 0.5 - 0.25,
                isAir: isAirBanana
            });
        }

        function updateBananas(deltaTime, currentTime) {
            // Spawn new bananas
            if (currentTime - lastBananaSpawn > BANANA_SPAWN_RATE) {
                if (Math.random() > 0.3) { // 70% chance to spawn
                    spawnBanana();
                }
                lastBananaSpawn = currentTime;
            }

            // Update positions
            bananas.forEach(banana => {
                banana.x -= DifficultyManager.currentSpeed;
            });

            // Remove off-screen bananas
            bananas = bananas.filter(banana => banana.x > -50);
        }

        function drawBanana(banana) {
            ctx.save();
            ctx.translate(banana.x + banana.width / 2, banana.y + banana.height / 2);
            ctx.rotate(banana.rotation + Math.sin(Date.now() / 300) * 0.1);

            // Single banana - curved crescent shape
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            // Outer curve
            ctx.moveTo(-12, 5);
            ctx.quadraticCurveTo(-8, -12, 8, -10);
            ctx.quadraticCurveTo(14, -8, 15, -2);
            // Inner curve
            ctx.quadraticCurveTo(12, -6, 6, -6);
            ctx.quadraticCurveTo(-4, -6, -8, 2);
            ctx.closePath();
            ctx.fill();

            // Darker yellow for depth
            ctx.fillStyle = '#E6BE00';
            ctx.beginPath();
            ctx.moveTo(-10, 3);
            ctx.quadraticCurveTo(-6, -8, 6, -7);
            ctx.quadraticCurveTo(10, -6, 12, -3);
            ctx.quadraticCurveTo(8, -4, 4, -4);
            ctx.quadraticCurveTo(-4, -4, -8, 1);
            ctx.closePath();
            ctx.fill();

            // Stem end (top)
            ctx.fillStyle = '#6B4423';
            ctx.beginPath();
            ctx.arc(14, -3, 2.5, 0, Math.PI * 2);
            ctx.fill();

            // Bottom tip
            ctx.fillStyle = '#4A3015';
            ctx.beginPath();
            ctx.ellipse(-11, 4, 2, 3, 0.5, 0, Math.PI * 2);
            ctx.fill();

            // Highlight shine
            ctx.strokeStyle = 'rgba(255, 255, 240, 0.6)';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-4, -4);
            ctx.quadraticCurveTo(2, -8, 8, -6);
            ctx.stroke();

            ctx.restore();
        }

        // ============================================
        // PATTERN CHUNK 8: Collision Detection
        // ============================================
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function checkCollisions() {
            const monkeyBounds = monkey.getBounds();

            // Check snake collisions
            for (const snake of snakes) {
                const snakeBounds = {
                    x: snake.x + 10,
                    y: snake.y,
                    width: snake.width - 10,
                    height: snake.height
                };
                if (checkCollision(monkeyBounds, snakeBounds)) {
                    return 'death';
                }
            }

            // Check banana collisions
            for (let i = bananas.length - 1; i >= 0; i--) {
                const banana = bananas[i];
                const bananaBounds = {
                    x: banana.x,
                    y: banana.y,
                    width: banana.width,
                    height: banana.height
                };
                if (checkCollision(monkeyBounds, bananaBounds)) {
                    bananas.splice(i, 1);
                    score += 50;
                    AudioManager.playCollect();
                }
            }

            return null;
        }

        // ============================================
        // PATTERN CHUNK 5: Ground & Scrolling Background
        // ============================================
        let bgOffset = 0;
        let cloudOffset = 0;

        function drawBackground() {
            // Sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
            skyGradient.addColorStop(0, '#87CEEB');
            skyGradient.addColorStop(1, '#E0F6FF');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, GROUND_Y);

            // Sun
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(650, 60, 40, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFF8DC';
            ctx.beginPath();
            ctx.arc(650, 60, 30, 0, Math.PI * 2);
            ctx.fill();

            // Clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            drawCloud(100 - cloudOffset % 900, 50);
            drawCloud(400 - cloudOffset % 900, 80);
            drawCloud(700 - cloudOffset % 900, 40);
            drawCloud(1000 - cloudOffset % 900, 70);

            // Far background hill/ground for trees
            ctx.fillStyle = '#2D5016';
            ctx.beginPath();
            ctx.moveTo(0, GROUND_Y - 40);
            ctx.lineTo(CANVAS_WIDTH, GROUND_Y - 40);
            ctx.lineTo(CANVAS_WIDTH, GROUND_Y);
            ctx.lineTo(0, GROUND_Y);
            ctx.closePath();
            ctx.fill();

            // Background trees (far) - on the far ground
            for (let i = 0; i < 10; i++) {
                const x = (i * 120 - (bgOffset * 0.3) % 120) - 60;
                drawTree(x, GROUND_Y - 40, 0.6, '#1B4D1B');
            }

            // Middle ground layer
            ctx.fillStyle = '#3D6B1E';
            ctx.beginPath();
            ctx.moveTo(0, GROUND_Y - 20);
            ctx.lineTo(CANVAS_WIDTH, GROUND_Y - 20);
            ctx.lineTo(CANVAS_WIDTH, GROUND_Y);
            ctx.lineTo(0, GROUND_Y);
            ctx.closePath();
            ctx.fill();

            // Middle trees - on middle ground
            for (let i = 0; i < 8; i++) {
                const x = (i * 150 - (bgOffset * 0.5) % 150) - 75;
                drawTree(x, GROUND_Y - 20, 0.8, '#228B22');
            }

            // Foreground grass layer
            ctx.fillStyle = '#4A7C23';
            ctx.beginPath();
            ctx.moveTo(0, GROUND_Y - 5);
            ctx.lineTo(CANVAS_WIDTH, GROUND_Y - 5);
            ctx.lineTo(CANVAS_WIDTH, GROUND_Y);
            ctx.lineTo(0, GROUND_Y);
            ctx.closePath();
            ctx.fill();

            // Foreground bushes
            ctx.fillStyle = '#32CD32';
            for (let i = 0; i < 12; i++) {
                const x = (i * 100 - (bgOffset * 0.7) % 100) - 50;
                drawBush(x, GROUND_Y - 15);
            }

            // Main ground (path/dirt)
            const groundGradient = ctx.createLinearGradient(0, GROUND_Y, 0, CANVAS_HEIGHT);
            groundGradient.addColorStop(0, '#8B4513');
            groundGradient.addColorStop(0.3, '#654321');
            groundGradient.addColorStop(1, '#3D2314');
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, CANVAS_HEIGHT - GROUND_Y);

            // Grass on top of ground
            ctx.strokeStyle = '#228B22';
            ctx.lineWidth = 2;
            for (let i = 0; i < 100; i++) {
                const x = (i * 12 - bgOffset % 12);
                ctx.beginPath();
                ctx.moveTo(x, GROUND_Y);
                ctx.lineTo(x + 3, GROUND_Y - 8 - Math.random() * 5);
                ctx.stroke();
            }
        }

        function drawCloud(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, 25, 0, Math.PI * 2);
            ctx.arc(x + 25, y - 10, 30, 0, Math.PI * 2);
            ctx.arc(x + 50, y, 25, 0, Math.PI * 2);
            ctx.arc(x + 25, y + 5, 20, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTree(x, y, scale, color) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);

            // Trunk
            ctx.fillStyle = '#4A3728';
            ctx.fillRect(-8, 0, 16, 60);

            // Foliage
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0, -80);
            ctx.lineTo(-40, 0);
            ctx.lineTo(40, 0);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(0, -50);
            ctx.lineTo(-35, 20);
            ctx.lineTo(35, 20);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        function drawBush(x, y) {
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, Math.PI * 2);
            ctx.arc(x + 15, y - 5, 18, 0, Math.PI * 2);
            ctx.arc(x + 30, y, 20, 0, Math.PI * 2);
            ctx.fill();
        }

        // ============================================
        // PATTERN CHUNK 9: Score System
        // ============================================
        function updateScore(deltaTime) {
            score += deltaTime * 0.01; // Time-based score
        }

        function updateUI() {
            document.getElementById('scoreDisplay').textContent = `Score: ${Math.floor(score)}`;
            document.getElementById('highScoreDisplay').textContent = `High Score: ${highScore}`;
        }

        // ============================================
        // PATTERN CHUNK 2: Game Loop
        // ============================================
        function gameLoop(timestamp) {
            if (lastTime === 0) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            if (currentState === GameState.PLAYING) {
                const elapsedTime = timestamp - gameStartTime;

                // Update difficulty
                DifficultyManager.update(elapsedTime);

                // Update background offset
                bgOffset += DifficultyManager.currentSpeed;
                cloudOffset += DifficultyManager.currentSpeed * 0.2;

                // Update game objects
                monkey.update(deltaTime);
                updateSnakes(deltaTime, elapsedTime);
                updateBananas(deltaTime, elapsedTime);
                updateScore(deltaTime);

                // Check collisions
                const collisionResult = checkCollisions();
                if (collisionResult === 'death' && !monkey.isDead) {
                    monkey.isDead = true;
                    monkey.velocityY = -10;
                    setTimeout(() => {
                        endGame();
                    }, 1000);
                }

                // Draw everything
                drawBackground();

                // Draw snakes
                snakes.forEach(drawSnake);

                // Draw bananas
                bananas.forEach(drawBanana);

                // Draw monkey
                monkey.draw();

                // Update UI
                updateUI();
            }

            requestAnimationFrame(gameLoop);
        }

        // ============================================
        // Game Control Functions
        // ============================================
        function startGame() {
            currentState = GameState.PLAYING;
            score = 0;
            snakes = [];
            bananas = [];
            lastSnakeSpawn = 0;
            lastBananaSpawn = 0;
            nextSnakeDelay = 1500;
            gameStartTime = performance.now();
            isNewRecord = false;

            monkey.reset();
            DifficultyManager.reset();
            AudioManager.init();

            document.getElementById('overlay').classList.add('hidden');
        }

        function endGame() {
            currentState = GameState.GAME_OVER;
            isNewRecord = HighScoreManager.set(Math.floor(score));
            if (isNewRecord) {
                highScore = Math.floor(score);
            }
            showGameOver();
        }

        function showGameOver() {
            const overlay = document.getElementById('overlay');
            overlay.innerHTML = `
                <h2>GAME OVER</h2>
                <p class="score-display">Score: ${Math.floor(score)}</p>
                <p class="score-display high-score">High Score: ${highScore}</p>
                ${isNewRecord ? '<p class="new-record">üéâ NEW RECORD! üéâ</p>' : ''}
                <p>Level Reached: ${DifficultyManager.level}</p>
                <button id="restartBtn">PLAY AGAIN</button>
            `;
            overlay.classList.remove('hidden');

            document.getElementById('restartBtn').addEventListener('click', startGame);
        }

        function showMenu() {
            const overlay = document.getElementById('overlay');
            document.getElementById('menuHighScore').textContent = `High Score: ${highScore}`;
            overlay.classList.remove('hidden');
        }

        // ============================================
        // PATTERN CHUNK 4: Jump Mechanics (Input)
        // ============================================
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (currentState === GameState.PLAYING) {
                    monkey.jump();
                } else if (currentState === GameState.MENU) {
                    startGame();
                } else if (currentState === GameState.GAME_OVER) {
                    startGame();
                }
            }
        });

        // Start button
        document.getElementById('startBtn').addEventListener('click', startGame);

        // Initialize
        highScore = HighScoreManager.get();
        document.getElementById('menuHighScore').textContent = `High Score: ${highScore}`;
        document.getElementById('highScoreDisplay').textContent = `High Score: ${highScore}`;

        // Draw initial background
        drawBackground();

        // Start game loop
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
