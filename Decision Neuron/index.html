<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decision Neuron - Should I Go to the Gym?</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
        }

        canvas {
            display: block;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(30, 30, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            min-width: 280px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid #ff6b35;
            z-index: 100;
        }

        .controls h2 {
            font-size: 1.1rem;
            margin-bottom: 5px;
            color: #ff6b35;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .controls .subtitle {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 107, 53, 0.3);
        }

        .controls h3 {
            font-size: 0.75rem;
            margin: 15px 0 10px;
            color: #7fff00;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            margin-bottom: 4px;
            color: #c0c0c0;
        }

        .control-group label span {
            color: #ff6b35;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 0.75rem;
        }

        .control-group .helper {
            font-size: 0.65rem;
            color: #666;
            margin-bottom: 4px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255, 107, 53, 0.2);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: linear-gradient(135deg, #ff6b35, #ff8c5a);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(255, 107, 53, 0.5);
        }

        .decision-display {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(30, 30, 35, 0.95);
            padding: 20px 30px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid #444;
            z-index: 100;
        }

        .decision-label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 8px;
        }

        .decision-result {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 0 0 20px currentColor;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .decision-result.go {
            color: #7fff00;
        }

        .decision-result.skip {
            color: #ff4444;
        }

        .decision-score {
            font-size: 0.9rem;
            color: #ff6b35;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        }

        .formula-display {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(30, 30, 35, 0.9);
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 0.75rem;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            border: 1px solid rgba(255, 107, 53, 0.3);
            z-index: 100;
            max-width: 500px;
        }

        .formula-display .formula-title {
            color: #ff6b35;
            margin-bottom: 8px;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .formula-display .formula-line {
            margin: 4px 0;
            color: #a0a0a0;
        }

        .formula-display .positive {
            color: #7fff00;
        }

        .formula-display .negative {
            color: #ff4444;
        }

        .formula-display .result {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 107, 53, 0.3);
            color: #ff6b35;
        }

        .toggle-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(30, 30, 35, 0.95);
            color: #ff6b35;
            border: 2px solid #ff6b35;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            display: none;
            z-index: 101;
            font-weight: bold;
            text-transform: uppercase;
        }

        @media (max-width: 800px) {
            .controls {
                display: none;
            }

            .controls.visible {
                display: block;
                top: 60px;
                right: 10px;
                left: 10px;
                min-width: auto;
            }

            .toggle-btn {
                display: block;
            }

            .formula-display {
                display: none;
            }

            .decision-display {
                left: 10px;
                right: 10px;
                top: auto;
                bottom: 20px;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="decision-display">
        <div class="decision-label">Decision</div>
        <div class="decision-result go" id="decisionResult">HIT THE GYM</div>
        <div class="decision-score">Score: <span id="decisionScore">0.50</span></div>
    </div>

    <div class="formula-display">
        <div class="formula-title">Workout Calculator</div>
        <div class="formula-line" id="formula1"></div>
        <div class="formula-line" id="formula2"></div>
        <div class="formula-line" id="formula3"></div>
        <div class="formula-line" id="formulaBias"></div>
        <div class="formula-line result" id="formulaResult"></div>
    </div>

    <button class="toggle-btn" onclick="toggleControls()">Controls</button>

    <div class="controls" id="controls">
        <h2>Gym Brain</h2>
        <div class="subtitle">Should I go to the gym in the morning?</div>

        <h3>Input Factors</h3>
        <div class="control-group">
            <label>Bedtime <span id="bedtimeValue">11pm</span></label>
            <div class="helper">Earlier = more likely to go</div>
            <input type="range" id="bedtimeSlider" min="-1" max="1" step="0.05" value="0">
        </div>
        <div class="control-group">
            <label>Gym Time <span id="gymTimeValue">7am</span></label>
            <div class="helper">Later = more likely to go</div>
            <input type="range" id="gymTimeSlider" min="-1" max="1" step="0.05" value="0">
        </div>
        <div class="control-group">
            <label>Morning Busyness <span id="busyValue">Normal</span></label>
            <div class="helper">Less busy = more likely to go</div>
            <input type="range" id="busySlider" min="-1" max="1" step="0.05" value="0">
        </div>

        <h3>Level of Importance</h3>
        <div class="control-group">
            <label>Bedtime Weight <span id="w1Value">1.00</span></label>
            <input type="range" id="w1Slider" min="-2" max="2" step="0.1" value="1">
        </div>
        <div class="control-group">
            <label>Gym Time Weight <span id="w2Value">0.80</span></label>
            <input type="range" id="w2Slider" min="-2" max="2" step="0.1" value="0.8">
        </div>
        <div class="control-group">
            <label>Busyness Weight <span id="w3Value">-0.50</span></label>
            <input type="range" id="w3Slider" min="-2" max="2" step="0.1" value="-0.5">
        </div>

        <h3>Bias</h3>
        <div class="control-group">
            <label>Health Consciousness <span id="biasValue">0.50</span></label>
            <div class="helper">Baseline motivation to exercise</div>
            <input type="range" id="biasSlider" min="-2" max="2" step="0.1" value="0.5">
        </div>

        <h3>Threshold</h3>
        <div class="control-group">
            <label>Decision Threshold <span id="thresholdValue">0.00</span></label>
            <div class="helper">Score must exceed this to GO</div>
            <input type="range" id="thresholdSlider" min="-2" max="2" step="0.1" value="0">
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;

        // Perceptron parameters
        const params = {
            bedtime: 0,
            gymTime: 0,
            busyness: 0,
            w1: 1.0,
            w2: 0.8,
            w3: -0.5,
            bias: 0.5,
            threshold: 0
        };

        // Animation state
        let pulses = [];
        let time = 0;

        // Node positions (will be calculated on resize)
        let nodes = {
            inputs: [],
            neuron: { x: 0, y: 0 },
            output: { x: 0, y: 0 },
            bias: { x: 0, y: 0 }
        };

        function init() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            // Calculate node positions
            const centerY = height / 2;
            const leftX = width * 0.2;
            const neuronX = width * 0.5;
            const rightX = width * 0.75;
            const spacing = height * 0.2;

            nodes.inputs = [
                { x: leftX, y: centerY - spacing, label: 'Bedtime', value: params.bedtime },
                { x: leftX, y: centerY, label: 'Gym Time', value: params.gymTime },
                { x: leftX, y: centerY + spacing, label: 'Busyness', value: params.busyness }
            ];
            nodes.neuron = { x: neuronX, y: centerY };
            nodes.output = { x: rightX, y: centerY };
            nodes.bias = { x: neuronX, y: centerY + spacing * 1.5, label: 'Bias' };
        }

        function calculateDecision() {
            const term1 = params.bedtime * params.w1;
            const term2 = params.gymTime * params.w2;
            const term3 = params.busyness * params.w3;
            const score = term1 + term2 + term3 + params.bias;
            return { score, term1, term2, term3, go: score > params.threshold };
        }

        function updateDisplay() {
            const decision = calculateDecision();

            // Update decision display
            const resultEl = document.getElementById('decisionResult');
            resultEl.textContent = decision.go ? 'HIT THE GYM' : 'REST DAY';
            resultEl.className = 'decision-result ' + (decision.go ? 'go' : 'skip');
            document.getElementById('decisionScore').textContent = decision.score.toFixed(2);

            // Update formula display
            const formatTerm = (val, weight, result) => {
                const sign = result >= 0 ? '+' : '';
                const cls = result >= 0 ? 'positive' : 'negative';
                return `<span class="${cls}">${val.toFixed(2)} × ${weight.toFixed(2)} = ${sign}${result.toFixed(2)}</span>`;
            };

            document.getElementById('formula1').innerHTML = `Bedtime: ${formatTerm(params.bedtime, params.w1, decision.term1)}`;
            document.getElementById('formula2').innerHTML = `Gym Time: ${formatTerm(params.gymTime, params.w2, decision.term2)}`;
            document.getElementById('formula3').innerHTML = `Busyness: ${formatTerm(params.busyness, params.w3, decision.term3)}`;
            document.getElementById('formulaBias').innerHTML = `Bias: <span class="${params.bias >= 0 ? 'positive' : 'negative'}">${params.bias >= 0 ? '+' : ''}${params.bias.toFixed(2)}</span>`;
            document.getElementById('formulaResult').innerHTML = `Total: ${decision.score.toFixed(2)} ${decision.go ? '> ' : '≤ '}${params.threshold.toFixed(2)} → <strong>${decision.go ? 'WORKOUT!' : 'REST'}</strong>`;

            // Update node values
            nodes.inputs[0].value = params.bedtime;
            nodes.inputs[1].value = params.gymTime;
            nodes.inputs[2].value = params.busyness;
        }

        function drawGlow(x, y, radius, color, intensity = 1) {
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius * 2);
            gradient.addColorStop(0, color.replace(')', `, ${0.4 * intensity})`).replace('rgb', 'rgba'));
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, radius * 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw a dumbbell shape for input nodes
        function drawDumbbell(x, y, size, color, label, value) {
            const barWidth = size * 2;
            const barHeight = size * 0.3;
            const plateRadius = size * 0.6;

            // Glow effect
            drawGlow(x, y, size, color);

            // Draw bar
            ctx.fillStyle = '#555';
            ctx.fillRect(x - barWidth/2, y - barHeight/2, barWidth, barHeight);

            // Left weight plate
            const plateGradient = ctx.createRadialGradient(x - barWidth/2, y, 0, x - barWidth/2, y, plateRadius);
            plateGradient.addColorStop(0, '#888');
            plateGradient.addColorStop(0.5, color);
            plateGradient.addColorStop(1, '#333');
            ctx.beginPath();
            ctx.arc(x - barWidth/2, y, plateRadius, 0, Math.PI * 2);
            ctx.fillStyle = plateGradient;
            ctx.fill();
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Right weight plate
            const plateGradient2 = ctx.createRadialGradient(x + barWidth/2, y, 0, x + barWidth/2, y, plateRadius);
            plateGradient2.addColorStop(0, '#888');
            plateGradient2.addColorStop(0.5, color);
            plateGradient2.addColorStop(1, '#333');
            ctx.beginPath();
            ctx.arc(x + barWidth/2, y, plateRadius, 0, Math.PI * 2);
            ctx.fillStyle = plateGradient2;
            ctx.fill();
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Label
            ctx.fillStyle = '#ff6b35';
            ctx.font = 'bold 12px -apple-system, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(label, x, y - size - 10);

            // Value
            if (value !== null) {
                ctx.fillStyle = '#7fff00';
                ctx.font = 'bold 11px SF Mono, Monaco, monospace';
                ctx.fillText(value.toFixed(2), x, y + 5);
            }
        }

        // Draw weight plate for central neuron
        function drawWeightPlate(x, y, radius, color, label, value) {
            // Outer glow
            drawGlow(x, y, radius * 1.5, color, 1.2);

            // Outer ring
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            const outerGrad = ctx.createRadialGradient(x, y, radius * 0.7, x, y, radius);
            outerGrad.addColorStop(0, color);
            outerGrad.addColorStop(1, '#222');
            ctx.fillStyle = outerGrad;
            ctx.fill();

            // Middle ring
            ctx.beginPath();
            ctx.arc(x, y, radius * 0.75, 0, Math.PI * 2);
            ctx.fillStyle = '#333';
            ctx.fill();

            // Inner plate
            ctx.beginPath();
            ctx.arc(x, y, radius * 0.6, 0, Math.PI * 2);
            const innerGrad = ctx.createRadialGradient(x - radius * 0.2, y - radius * 0.2, 0, x, y, radius * 0.6);
            innerGrad.addColorStop(0, '#666');
            innerGrad.addColorStop(0.5, color);
            innerGrad.addColorStop(1, '#222');
            ctx.fillStyle = innerGrad;
            ctx.fill();

            // Center hole
            ctx.beginPath();
            ctx.arc(x, y, radius * 0.15, 0, Math.PI * 2);
            ctx.fillStyle = '#1a1a1a';
            ctx.fill();

            // Decorative lines on plate
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(x + Math.cos(angle) * radius * 0.2, y + Math.sin(angle) * radius * 0.2);
                ctx.lineTo(x + Math.cos(angle) * radius * 0.55, y + Math.sin(angle) * radius * 0.55);
                ctx.stroke();
            }

            // Label
            ctx.fillStyle = '#ff6b35';
            ctx.font = 'bold 12px -apple-system, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(label, x, y - radius - 12);

            // Value in center
            if (value !== null) {
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px SF Mono, Monaco, monospace';
                ctx.fillText(value.toFixed(2), x, y + 5);
            }
        }

        // Draw kettlebell for output
        function drawKettlebell(x, y, size, color, isGo) {
            // Glow
            drawGlow(x, y, size, color, 1.5);

            // Handle
            ctx.beginPath();
            ctx.arc(x, y - size * 0.3, size * 0.5, Math.PI, 0, false);
            ctx.lineWidth = size * 0.2;
            ctx.strokeStyle = '#444';
            ctx.stroke();
            ctx.lineWidth = size * 0.15;
            ctx.strokeStyle = '#666';
            ctx.stroke();

            // Body (bell part)
            const bodyGrad = ctx.createRadialGradient(x - size * 0.2, y + size * 0.1, 0, x, y + size * 0.3, size * 0.8);
            bodyGrad.addColorStop(0, '#888');
            bodyGrad.addColorStop(0.3, color);
            bodyGrad.addColorStop(1, '#222');

            ctx.beginPath();
            ctx.arc(x, y + size * 0.3, size * 0.7, 0, Math.PI * 2);
            ctx.fillStyle = bodyGrad;
            ctx.fill();
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Text
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${size * 0.4}px -apple-system, sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText(isGo ? 'GO' : 'REST', x, y + size * 0.4);

            // Label
            ctx.fillStyle = color;
            ctx.font = 'bold 14px -apple-system, sans-serif';
            ctx.fillText(isGo ? 'WORKOUT!' : 'SKIP', x, y - size - 5);
        }

        // Draw heart rate monitor style node for bias
        function drawHeartNode(x, y, radius, color, label, value) {
            drawGlow(x, y, radius, color);

            // Heart shape
            ctx.beginPath();
            const heartSize = radius * 0.8;
            ctx.moveTo(x, y + heartSize * 0.3);
            ctx.bezierCurveTo(x, y - heartSize * 0.3, x - heartSize, y - heartSize * 0.3, x - heartSize, y + heartSize * 0.1);
            ctx.bezierCurveTo(x - heartSize, y + heartSize * 0.6, x, y + heartSize, x, y + heartSize);
            ctx.bezierCurveTo(x, y + heartSize, x + heartSize, y + heartSize * 0.6, x + heartSize, y + heartSize * 0.1);
            ctx.bezierCurveTo(x + heartSize, y - heartSize * 0.3, x, y - heartSize * 0.3, x, y + heartSize * 0.3);

            const heartGrad = ctx.createRadialGradient(x, y, 0, x, y, radius);
            heartGrad.addColorStop(0, '#ff6b6b');
            heartGrad.addColorStop(0.5, color);
            heartGrad.addColorStop(1, '#8b0000');
            ctx.fillStyle = heartGrad;
            ctx.fill();

            // Label
            ctx.fillStyle = '#ff6b35';
            ctx.font = 'bold 11px -apple-system, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(label, x, y + radius + 20);

            // Value
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 10px SF Mono, Monaco, monospace';
            ctx.fillText(value.toFixed(2), x, y + radius * 0.5);
        }

        function drawConnection(x1, y1, x2, y2, weight, inputValue) {
            const contribution = inputValue * weight;
            const isPositive = contribution >= 0;
            const intensity = Math.min(Math.abs(contribution), 1);

            // Create gradient for the connection
            const grad = ctx.createLinearGradient(x1, y1, x2, y2);
            if (isPositive) {
                grad.addColorStop(0, `rgba(127, 255, 0, ${0.3 + intensity * 0.5})`);
                grad.addColorStop(1, `rgba(255, 107, 53, ${0.3 + intensity * 0.5})`);
            } else {
                grad.addColorStop(0, `rgba(255, 68, 68, ${0.3 + intensity * 0.5})`);
                grad.addColorStop(1, `rgba(139, 0, 0, ${0.3 + intensity * 0.5})`);
            }

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = grad;
            ctx.lineWidth = 3 + Math.abs(weight) * 2;
            ctx.stroke();

            // Weight label at midpoint
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px SF Mono, Monaco, monospace';
            ctx.textAlign = 'center';

            // Background for text
            const text = `×${weight.toFixed(1)}`;
            const textWidth = ctx.measureText(text).width;
            ctx.fillStyle = 'rgba(30, 30, 35, 0.8)';
            ctx.fillRect(midX - textWidth/2 - 4, midY - 18, textWidth + 8, 16);

            ctx.fillStyle = isPositive ? '#7fff00' : '#ff4444';
            ctx.fillText(text, midX, midY - 6);
        }

        function drawPulse(pulse) {
            const t = pulse.progress;
            const x = pulse.x1 + (pulse.x2 - pulse.x1) * t;
            const y = pulse.y1 + (pulse.y2 - pulse.y1) * t;

            const color = pulse.positive ? 'rgb(127, 255, 0)' : 'rgb(255, 68, 68)';
            drawGlow(x, y, 10, color, 1 - t * 0.5);

            // Draw as small dumbbell/weight
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function spawnPulses() {
            const weights = [params.w1, params.w2, params.w3];
            const values = [params.bedtime, params.gymTime, params.busyness];

            nodes.inputs.forEach((input, i) => {
                if (Math.random() < 0.025) {
                    const contribution = values[i] * weights[i];
                    pulses.push({
                        x1: input.x + 40,
                        y1: input.y,
                        x2: nodes.neuron.x - 50,
                        y2: nodes.neuron.y,
                        progress: 0,
                        speed: 0.015 + Math.random() * 0.01,
                        positive: contribution >= 0
                    });
                }
            });

            // Bias pulse
            if (Math.random() < 0.02) {
                pulses.push({
                    x1: nodes.bias.x,
                    y1: nodes.bias.y - 25,
                    x2: nodes.neuron.x,
                    y2: nodes.neuron.y + 40,
                    progress: 0,
                    speed: 0.02,
                    positive: params.bias >= 0
                });
            }

            // Output pulse
            const decision = calculateDecision();
            if (Math.random() < 0.03) {
                pulses.push({
                    x1: nodes.neuron.x + 50,
                    y1: nodes.neuron.y,
                    x2: nodes.output.x - 40,
                    y2: nodes.output.y,
                    progress: 0,
                    speed: 0.02,
                    positive: decision.go
                });
            }
        }

        function render() {
            // Dark gym floor background
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);

            // Subtle gym floor pattern
            ctx.strokeStyle = 'rgba(255, 107, 53, 0.03)';
            ctx.lineWidth = 1;
            for (let x = 0; x < width; x += 80) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            for (let y = 0; y < height; y += 80) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // Accent lines
            ctx.strokeStyle = 'rgba(127, 255, 0, 0.05)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, height * 0.3);
            ctx.lineTo(width, height * 0.3);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, height * 0.7);
            ctx.lineTo(width, height * 0.7);
            ctx.stroke();

            const decision = calculateDecision();
            const weights = [params.w1, params.w2, params.w3];
            const values = [params.bedtime, params.gymTime, params.busyness];

            // Draw connections from inputs to neuron
            nodes.inputs.forEach((input, i) => {
                drawConnection(input.x + 40, input.y, nodes.neuron.x - 50, nodes.neuron.y, weights[i], values[i]);
            });

            // Draw bias connection
            const biasGrad = ctx.createLinearGradient(nodes.bias.x, nodes.bias.y, nodes.neuron.x, nodes.neuron.y);
            biasGrad.addColorStop(0, params.bias >= 0 ? 'rgba(255, 107, 107, 0.6)' : 'rgba(139, 0, 0, 0.6)');
            biasGrad.addColorStop(1, params.bias >= 0 ? 'rgba(255, 107, 53, 0.6)' : 'rgba(100, 0, 0, 0.6)');
            ctx.beginPath();
            ctx.moveTo(nodes.bias.x, nodes.bias.y - 25);
            ctx.lineTo(nodes.neuron.x, nodes.neuron.y + 40);
            ctx.strokeStyle = biasGrad;
            ctx.lineWidth = 3 + Math.abs(params.bias);
            ctx.stroke();

            // Draw output connection
            const outGrad = ctx.createLinearGradient(nodes.neuron.x, nodes.neuron.y, nodes.output.x, nodes.output.y);
            if (decision.go) {
                outGrad.addColorStop(0, 'rgba(255, 107, 53, 0.8)');
                outGrad.addColorStop(1, 'rgba(127, 255, 0, 0.8)');
            } else {
                outGrad.addColorStop(0, 'rgba(139, 0, 0, 0.6)');
                outGrad.addColorStop(1, 'rgba(255, 68, 68, 0.6)');
            }
            ctx.beginPath();
            ctx.moveTo(nodes.neuron.x + 50, nodes.neuron.y);
            ctx.lineTo(nodes.output.x - 40, nodes.output.y);
            ctx.strokeStyle = outGrad;
            ctx.lineWidth = 5;
            ctx.stroke();

            // Draw pulses
            pulses.forEach(pulse => drawPulse(pulse));

            // Draw input nodes as dumbbells
            const labels = ['Sleep', 'Wake Up', 'Schedule'];
            nodes.inputs.forEach((input, i) => {
                const inputColor = values[i] * weights[i] >= 0 ? '#7fff00' : '#ff4444';
                drawDumbbell(input.x, input.y, 25, inputColor, labels[i], values[i]);
            });

            // Draw neuron as weight plate
            const neuronColor = decision.go ? '#ff6b35' : '#666';
            drawWeightPlate(nodes.neuron.x, nodes.neuron.y, 55, neuronColor, 'BRAIN', decision.score);

            // Draw output as kettlebell
            const outputColor = decision.go ? '#7fff00' : '#ff4444';
            drawKettlebell(nodes.output.x, nodes.output.y, 40, outputColor, decision.go);

            // Draw bias as heart
            const heartColor = params.bias >= 0 ? '#ff6b6b' : '#8b0000';
            drawHeartNode(nodes.bias.x, nodes.bias.y, 25, heartColor, 'Motivation', params.bias);
        }

        function animate() {
            time += 0.016;

            // Update pulses
            pulses = pulses.filter(pulse => {
                pulse.progress += pulse.speed;
                return pulse.progress < 1;
            });

            spawnPulses();
            render();
            requestAnimationFrame(animate);
        }

        function formatBedtime(val) {
            if (val <= -0.67) return '8pm';
            if (val <= -0.33) return '9pm';
            if (val <= 0) return '10pm';
            if (val <= 0.33) return '11pm';
            if (val <= 0.67) return '12am';
            if (val <= 1) return '1am';
            return '2am';
        }

        function formatGymTime(val) {
            if (val <= -0.67) return '9am';
            if (val <= -0.33) return '8am';
            if (val <= 0) return '7am';
            if (val <= 0.33) return '6am';
            if (val <= 0.67) return '5:30am';
            return '5am';
        }

        function formatBusyness(val) {
            if (val <= -0.5) return 'Free';
            if (val <= 0) return 'Light';
            if (val <= 0.5) return 'Normal';
            return 'Packed';
        }

        function setupControls() {
            // Input sliders
            document.getElementById('bedtimeSlider').addEventListener('input', (e) => {
                params.bedtime = parseFloat(e.target.value);
                document.getElementById('bedtimeValue').textContent = formatBedtime(params.bedtime);
                updateDisplay();
            });

            document.getElementById('gymTimeSlider').addEventListener('input', (e) => {
                params.gymTime = parseFloat(e.target.value);
                document.getElementById('gymTimeValue').textContent = formatGymTime(params.gymTime);
                updateDisplay();
            });

            document.getElementById('busySlider').addEventListener('input', (e) => {
                params.busyness = parseFloat(e.target.value);
                document.getElementById('busyValue').textContent = formatBusyness(params.busyness);
                updateDisplay();
            });

            // Weight sliders
            document.getElementById('w1Slider').addEventListener('input', (e) => {
                params.w1 = parseFloat(e.target.value);
                document.getElementById('w1Value').textContent = params.w1.toFixed(2);
                updateDisplay();
            });

            document.getElementById('w2Slider').addEventListener('input', (e) => {
                params.w2 = parseFloat(e.target.value);
                document.getElementById('w2Value').textContent = params.w2.toFixed(2);
                updateDisplay();
            });

            document.getElementById('w3Slider').addEventListener('input', (e) => {
                params.w3 = parseFloat(e.target.value);
                document.getElementById('w3Value').textContent = params.w3.toFixed(2);
                updateDisplay();
            });

            // Bias slider
            document.getElementById('biasSlider').addEventListener('input', (e) => {
                params.bias = parseFloat(e.target.value);
                document.getElementById('biasValue').textContent = params.bias.toFixed(2);
                updateDisplay();
            });

            // Threshold slider
            document.getElementById('thresholdSlider').addEventListener('input', (e) => {
                params.threshold = parseFloat(e.target.value);
                document.getElementById('thresholdValue').textContent = params.threshold.toFixed(2);
                updateDisplay();
            });
        }

        function toggleControls() {
            document.getElementById('controls').classList.toggle('visible');
        }

        window.addEventListener('resize', init);

        // Initialize
        init();
        setupControls();
        updateDisplay();
        animate();
    </script>
</body>
</html>
